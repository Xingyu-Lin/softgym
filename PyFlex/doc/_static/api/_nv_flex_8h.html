<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>FLEX: NvFlex.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="flex.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nvidia.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLEX
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NvFlex.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="_nv_flex_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:struct_nv_flex_params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_params">NvFlexParams</a></td></tr>
<tr class="separator:struct_nv_flex_params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_timers"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_timers">NvFlexTimers</a></td></tr>
<tr class="separator:struct_nv_flex_timers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_solver_callback_params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_callback_params">NvFlexSolverCallbackParams</a></td></tr>
<tr class="separator:struct_nv_flex_solver_callback_params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_flex_solver_callback.html">NvFlexSolverCallback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_init_desc"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_init_desc">NvFlexInitDesc</a></td></tr>
<tr class="separator:struct_nv_flex_init_desc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_solver_desc"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_desc">NvFlexSolverDesc</a></td></tr>
<tr class="separator:struct_nv_flex_solver_desc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_copy_desc"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a></td></tr>
<tr class="separator:struct_nv_flex_copy_desc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_sphere_geometry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_sphere_geometry">NvFlexSphereGeometry</a></td></tr>
<tr class="separator:struct_nv_flex_sphere_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_capsule_geometry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_capsule_geometry">NvFlexCapsuleGeometry</a></td></tr>
<tr class="separator:struct_nv_flex_capsule_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_box_geometry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_box_geometry">NvFlexBoxGeometry</a></td></tr>
<tr class="separator:struct_nv_flex_box_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_convex_mesh_geometry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_convex_mesh_geometry">NvFlexConvexMeshGeometry</a></td></tr>
<tr class="separator:struct_nv_flex_convex_mesh_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_triangle_mesh_geometry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_triangle_mesh_geometry">NvFlexTriangleMeshGeometry</a></td></tr>
<tr class="separator:struct_nv_flex_triangle_mesh_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_s_d_f_geometry"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_s_d_f_geometry">NvFlexSDFGeometry</a></td></tr>
<tr class="separator:struct_nv_flex_s_d_f_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:union_nv_flex_collision_geometry"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#union_nv_flex_collision_geometry">NvFlexCollisionGeometry</a></td></tr>
<tr class="separator:union_nv_flex_collision_geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_nv_flex_detail_timer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_detail_timer">NvFlexDetailTimer</a></td></tr>
<tr class="separator:struct_nv_flex_detail_timer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3078976e98f370a9fbdb11db80f1f318"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a></td></tr>
<tr class="separator:a3078976e98f370a9fbdb11db80f1f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaeb57f4ee7e54b1ae1b912a465ed39e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a></td></tr>
<tr class="separator:afaeb57f4ee7e54b1ae1b912a465ed39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a3933d3f7b77d0500c702b1fa9ba9a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a></td></tr>
<tr class="separator:a50a3933d3f7b77d0500c702b1fa9ba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6f00c9b94debbf7c181082a14076d5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#abe6f00c9b94debbf7c181082a14076d5">NvFlexErrorCallback</a>) (<a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfca">NvFlexErrorSeverity</a> type, const char *msg, const char *file, int line)</td></tr>
<tr class="separator:abe6f00c9b94debbf7c181082a14076d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aea4c3d772b4dbccb7dd9ba37c1bdc0"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a></td></tr>
<tr class="separator:a2aea4c3d772b4dbccb7dd9ba37c1bdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e990c5bfbc89677988cbf2471c0ade"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a></td></tr>
<tr class="separator:a56e990c5bfbc89677988cbf2471c0ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab5aa68da7ca1f69211a900f1a1c586"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a></td></tr>
<tr class="separator:a7ab5aa68da7ca1f69211a900f1a1c586"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6541b33eaca7b2323e73b30cea34d16c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a6541b33eaca7b2323e73b30cea34d16c">NvFlexMapFlags</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a6541b33eaca7b2323e73b30cea34d16ca11adf517d180983daec217e761acc3d6">eNvFlexMapWait</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a6541b33eaca7b2323e73b30cea34d16ca1bd450ab65ccc06288fae95e23d5e6f1">eNvFlexMapDoNotWait</a> = 1
<br />
 }</td></tr>
<tr class="separator:a6541b33eaca7b2323e73b30cea34d16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169e4c126acf46bdebf76c36a44deca3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3">NvFlexBufferType</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3aec63221ddc1b13eff4db55fbf6cd85f8">eNvFlexBufferHost</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3a103255fa795b55a7f430a41493002576">eNvFlexBufferDevice</a> = 1
<br />
 }</td></tr>
<tr class="separator:a169e4c126acf46bdebf76c36a44deca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f5d35902f7da40628247175a174f3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a46f5d35902f7da40628247175a174f3b">NvFlexRelaxationMode</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a46f5d35902f7da40628247175a174f3ba33711a4b466d606d68dee43918f819db">eNvFlexRelaxationGlobal</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a46f5d35902f7da40628247175a174f3ba858afe9529e908c2bc8ce92da8943b7c">eNvFlexRelaxationLocal</a> = 1
<br />
 }</td></tr>
<tr class="separator:a46f5d35902f7da40628247175a174f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad2a7745fcb4d4afd5b5f1bda074644"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644">NvFlexPhase</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644ad108f6ebf28346813cfd3602d984bb32">eNvFlexPhaseGroupMask</a> = 0x000fffff, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a7b776084468bae4e3566484cf34d0154">eNvFlexPhaseFlagsMask</a> = 0x00f00000, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644ae4ea43366942f719f40e8526ad21a038">eNvFlexPhaseShapeChannelMask</a> = 0x7f000000, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a453a23cc8e9d2e6097b5be187f3c6977">eNvFlexPhaseSelfCollide</a> = 1 &lt;&lt; 20, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a76a62d3a5df428f18e01f8b37573a7b1">eNvFlexPhaseSelfCollideFilter</a> = 1 &lt;&lt; 21, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a1728772beb1746ace4c549b2ed8f1d74">eNvFlexPhaseFluid</a> = 1 &lt;&lt; 22, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a52ee05f3e425c336856277774bc9f69f">eNvFlexPhaseUnused</a> = 1 &lt;&lt; 23, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a66aa70953a97744621e2afa41d0e32d2">eNvFlexPhaseShapeChannel0</a> = 1 &lt;&lt; 24, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a1de4e956764950e501bcb8376a70f5a9">eNvFlexPhaseShapeChannel1</a> = 1 &lt;&lt; 25, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644aa3a4fd0d5930b31199334e500ac2d7c8">eNvFlexPhaseShapeChannel2</a> = 1 &lt;&lt; 26, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644ab4034dbf78d6045ee13278531ee21c2b">eNvFlexPhaseShapeChannel3</a> = 1 &lt;&lt; 27, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644af309316efb695be38a4e15986be21ef9">eNvFlexPhaseShapeChannel4</a> = 1 &lt;&lt; 28, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a92bbb75d47ea0058a9a89deb0abec67f">eNvFlexPhaseShapeChannel5</a> = 1 &lt;&lt; 29, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644a0c8d08e646d2713e34d7e2dd6e7b21f2">eNvFlexPhaseShapeChannel6</a> = 1 &lt;&lt; 30
<br />
 }</td></tr>
<tr class="separator:a5ad2a7745fcb4d4afd5b5f1bda074644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4435b3857752360375fe52fc992cfca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfca">NvFlexErrorSeverity</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfcaa8aed6496f033604148138299fa075edd">eNvFlexLogError</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfcaa03d239332ae87f46270855dd06b6e58f">eNvFlexLogInfo</a> = 1, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfcaa5538835c4767004ba5fd443ada08ea61">eNvFlexLogWarning</a> = 2, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfcaa77b51759e33d60b2caf327bb4835351e">eNvFlexLogDebug</a> = 4, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfcaa8feff72c0b0391e8adf3ddb6c39ef10e">eNvFlexLogAll</a> = -1
<br />
 }</td></tr>
<tr class="separator:ab4435b3857752360375fe52fc992cfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f80c8bcfa6de99a52983adb13d80db9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9">NvFlexSolverCallbackStage</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9a9f3914fdb03915a14ebe55a2c730e7ff">eNvFlexStageIterationStart</a>, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9ab75a912c3990b0fbd6b06a6741a20e69">eNvFlexStageIterationEnd</a>, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9a79ce9005dbc92198a1f180c6afde6a44">eNvFlexStageSubstepBegin</a>, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9a6f13e2ebdbf21f8c8ebcfe1ac9160586">eNvFlexStageSubstepEnd</a>, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9a260340ba9071892bd8795c3b29289806">eNvFlexStageUpdateEnd</a>, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9a1f2e7acff9b3b74922f90240d29fd1b3">eNvFlexStageCount</a>
<br />
 }</td></tr>
<tr class="separator:a4f80c8bcfa6de99a52983adb13d80db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2d3dc5ac42011aeec4e13be2e14252"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a9b2d3dc5ac42011aeec4e13be2e14252">NvFlexComputeType</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a9b2d3dc5ac42011aeec4e13be2e14252ad0c27f7aafdc4fe569722025c8eb2178">eNvFlexCUDA</a>, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a9b2d3dc5ac42011aeec4e13be2e14252a297a93979a88fda6e6b551dcab5fb3df">eNvFlexD3D11</a>, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a9b2d3dc5ac42011aeec4e13be2e14252a15e78a7baf13cc7fd73f255ac84f0943">eNvFlexD3D12</a>
<br />
 }</td></tr>
<tr class="separator:a9b2d3dc5ac42011aeec4e13be2e14252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5c235d5fab40831cf339680aa25560"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aee5c235d5fab40831cf339680aa25560">NvFlexFeatureMode</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#aee5c235d5fab40831cf339680aa25560a3ab06dc4cd4aa073ab0f2d96a56c499d">eNvFlexFeatureModeDefault</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#aee5c235d5fab40831cf339680aa25560a421fe1e1bb00fc41e9b32208cd9155f5">eNvFlexFeatureModeSimpleSolids</a> = 1, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#aee5c235d5fab40831cf339680aa25560aeab2b8a68b528d46e11b71ad0f4d83f2">eNvFlexFeatureModeSimpleFluids</a> = 2
<br />
 }</td></tr>
<tr class="separator:aee5c235d5fab40831cf339680aa25560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0506ae712f846087b8647ea389ac26ba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26ba">NvFlexCollisionShapeType</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26baae22144512ae098865c6725af16a68ad3">eNvFlexShapeSphere</a> = 0, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26baa1724c140b583fbf2c11c14a24dd3764a">eNvFlexShapeCapsule</a> = 1, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26baab17c8dd4f9500016b77a9b49de3c48e7">eNvFlexShapeBox</a> = 2, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26baaed52f0e803c6745ffc1a5f018a8756ce">eNvFlexShapeConvexMesh</a> = 3, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26baa315488da382a5e9794c83358385f7ae1">eNvFlexShapeTriangleMesh</a> = 4, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26baa1fd78f8694b954f8d12fe7d911f17180">eNvFlexShapeSDF</a> = 5
<br />
 }</td></tr>
<tr class="separator:a0506ae712f846087b8647ea389ac26ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c31ea4f96cd4fdadc6b7317691304c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a31c31ea4f96cd4fdadc6b7317691304c">NvFlexCollisionShapeFlags</a> { <br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a31c31ea4f96cd4fdadc6b7317691304cae8a10737948abf6973f0f1d66bae7ef8">eNvFlexShapeFlagTypeMask</a> = 0x7, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a31c31ea4f96cd4fdadc6b7317691304cadc6740cf6d829fba159d92e43ffb5992">eNvFlexShapeFlagDynamic</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a31c31ea4f96cd4fdadc6b7317691304ca409215fa9b917f2d0830a66bd11b3ff8">eNvFlexShapeFlagTrigger</a> = 0x10, 
<br />
&#160;&#160;<a class="el" href="_nv_flex_8h.html#a31c31ea4f96cd4fdadc6b7317691304caa1c1225f6b8b2906c83748cfc46b81d9">eNvFlexShapeFlagReserved</a> = 0xffffff00
<br />
 }</td></tr>
<tr class="separator:a31c31ea4f96cd4fdadc6b7317691304c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a615e8070212c24a70e7a849120c13353"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a615e8070212c24a70e7a849120c13353">NvFlexMakePhaseWithChannels</a> (int group, int particleFlags, int shapeChannels)</td></tr>
<tr class="separator:a615e8070212c24a70e7a849120c13353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43db5f28808f8038cfc9330d4b47d57"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab43db5f28808f8038cfc9330d4b47d57">NvFlexMakePhase</a> (int group, int particleFlags)</td></tr>
<tr class="separator:ab43db5f28808f8038cfc9330d4b47d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687e5ec141948f779faa9183b68cb743"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a687e5ec141948f779faa9183b68cb743">NvFlexInit</a> (int version=NV_FLEX_VERSION, <a class="el" href="_nv_flex_8h.html#abe6f00c9b94debbf7c181082a14076d5">NvFlexErrorCallback</a> errorFunc=0, <a class="el" href="_nv_flex_8h.html#struct_nv_flex_init_desc">NvFlexInitDesc</a> *desc=0)</td></tr>
<tr class="separator:a687e5ec141948f779faa9183b68cb743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf59e45ada57c7f958a8030099cbe211"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aaf59e45ada57c7f958a8030099cbe211">NvFlexShutdown</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:aaf59e45ada57c7f958a8030099cbe211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25ec5de38c177db51198bb620644d36"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ac25ec5de38c177db51198bb620644d36">NvFlexGetVersion</a> ()</td></tr>
<tr class="separator:ac25ec5de38c177db51198bb620644d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a33d464c002a8916a5925c6ef32ae6"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a69a33d464c002a8916a5925c6ef32ae6">NvFlexSetSolverDescDefaults</a> (<a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_desc">NvFlexSolverDesc</a> *desc)</td></tr>
<tr class="separator:a69a33d464c002a8916a5925c6ef32ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e925acbc34675dfe247da017cbd855f"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a9e925acbc34675dfe247da017cbd855f">NvFlexCreateSolver</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_desc">NvFlexSolverDesc</a> *desc)</td></tr>
<tr class="separator:a9e925acbc34675dfe247da017cbd855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d755d7b090f7ed5c4c50d2d3fef1558"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a1d755d7b090f7ed5c4c50d2d3fef1558">NvFlexDestroySolver</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver)</td></tr>
<tr class="separator:a1d755d7b090f7ed5c4c50d2d3fef1558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53909027df03c6a352746d8ddc088ef"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ad53909027df03c6a352746d8ddc088ef">NvFlexGetSolvers</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> **solvers, int n)</td></tr>
<tr class="separator:ad53909027df03c6a352746d8ddc088ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d57e4fc2b3b51ec08f7da0a28ff343"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ae0d57e4fc2b3b51ec08f7da0a28ff343">NvFlexGetSolverLibrary</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver)</td></tr>
<tr class="separator:ae0d57e4fc2b3b51ec08f7da0a28ff343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6aff58269d6c359df2453c96397840"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#afd6aff58269d6c359df2453c96397840">NvFlexGetSolverDesc</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_desc">NvFlexSolverDesc</a> *desc)</td></tr>
<tr class="separator:afd6aff58269d6c359df2453c96397840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5427457488ab3f2de91cf65335dda08"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="struct_nv_flex_solver_callback.html">NvFlexSolverCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ac5427457488ab3f2de91cf65335dda08">NvFlexRegisterSolverCallback</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="struct_nv_flex_solver_callback.html">NvFlexSolverCallback</a> function, <a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9">NvFlexSolverCallbackStage</a> stage)</td></tr>
<tr class="separator:ac5427457488ab3f2de91cf65335dda08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75370f005fd453fe8a324fe62be1b5c"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, float dt, int substeps, bool enableTimers)</td></tr>
<tr class="separator:ac75370f005fd453fe8a324fe62be1b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2db6ad8006027c1acf2315a0d15fe71"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ae2db6ad8006027c1acf2315a0d15fe71">NvFlexSetParams</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_params">NvFlexParams</a> *params)</td></tr>
<tr class="separator:ae2db6ad8006027c1acf2315a0d15fe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581b458848039220203547af53de128f"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a581b458848039220203547af53de128f">NvFlexGetParams</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#struct_nv_flex_params">NvFlexParams</a> *params)</td></tr>
<tr class="separator:a581b458848039220203547af53de128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0c97635cdbb3da7b571574a3b38990"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#adc0c97635cdbb3da7b571574a3b38990">NvFlexSetActive</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:adc0c97635cdbb3da7b571574a3b38990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd4b70e0118abe18ca5fe85157299b6"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a1bd4b70e0118abe18ca5fe85157299b6">NvFlexGetActive</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:a1bd4b70e0118abe18ca5fe85157299b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677dc591fe443ae058701966c52d1316"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a677dc591fe443ae058701966c52d1316">NvFlexSetActiveCount</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, int n)</td></tr>
<tr class="separator:a677dc591fe443ae058701966c52d1316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2345372dea2ad4f043153a84e7a2c407"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a2345372dea2ad4f043153a84e7a2c407">NvFlexGetActiveCount</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver)</td></tr>
<tr class="separator:a2345372dea2ad4f043153a84e7a2c407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec5ebe3e98a44a2058d6be74b2cb633"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a7ec5ebe3e98a44a2058d6be74b2cb633">NvFlexSetParticles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *p, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:a7ec5ebe3e98a44a2058d6be74b2cb633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff62cfd50431d82af5d04a6c9ac4ffd"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aaff62cfd50431d82af5d04a6c9ac4ffd">NvFlexGetParticles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *p, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:aaff62cfd50431d82af5d04a6c9ac4ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125cfd9817437bb4f4bcb9418efa3dda"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a125cfd9817437bb4f4bcb9418efa3dda">NvFlexSetRestParticles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *p, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:a125cfd9817437bb4f4bcb9418efa3dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc89f87307602fb9bfa8f6668122121"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aafc89f87307602fb9bfa8f6668122121">NvFlexGetRestParticles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *p, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:aafc89f87307602fb9bfa8f6668122121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a771dd328d019e6164e5f23d29ffcb"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a96a771dd328d019e6164e5f23d29ffcb">NvFlexGetSmoothParticles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *p, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:a96a771dd328d019e6164e5f23d29ffcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b271f123db0054512936f2acc6467f"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ae2b271f123db0054512936f2acc6467f">NvFlexSetVelocities</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *v, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:ae2b271f123db0054512936f2acc6467f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcbff4e4865105514c194398ab3a7b0"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#afbcbff4e4865105514c194398ab3a7b0">NvFlexGetVelocities</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *v, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:afbcbff4e4865105514c194398ab3a7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d44495e442f8cae874c635ef847478"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aa1d44495e442f8cae874c635ef847478">NvFlexSetPhases</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *phases, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:aa1d44495e442f8cae874c635ef847478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc944f0e76ee2e5d67c3f977b150806"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#accc944f0e76ee2e5d67c3f977b150806">NvFlexGetPhases</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *phases, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:accc944f0e76ee2e5d67c3f977b150806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e8fdb39029a2564c129bd493c52058"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a32e8fdb39029a2564c129bd493c52058">NvFlexSetNormals</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *normals, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:a32e8fdb39029a2564c129bd493c52058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d87b460a34c52ff4b616e97a53ade7"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a73d87b460a34c52ff4b616e97a53ade7">NvFlexGetNormals</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *normals, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:a73d87b460a34c52ff4b616e97a53ade7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c0cab2ecee8eb9485a26ef0fad6a9"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ae67c0cab2ecee8eb9485a26ef0fad6a9">NvFlexSetSprings</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *restLengths, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *stiffness, int numSprings)</td></tr>
<tr class="separator:ae67c0cab2ecee8eb9485a26ef0fad6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5f90f4024d71d08c3f9327c6d8c184"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aab5f90f4024d71d08c3f9327c6d8c184">NvFlexGetSprings</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *restLengths, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *stiffness, int numSprings)</td></tr>
<tr class="separator:aab5f90f4024d71d08c3f9327c6d8c184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b7bfeffb0fa7dc6dbd291fee87edc9"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aa8b7bfeffb0fa7dc6dbd291fee87edc9">NvFlexSetRigids</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *offsets, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *restPositions, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *restNormals, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *stiffness, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *thresholds, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *creeps, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *rotations, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *translations, int numRigids, int numIndices)</td></tr>
<tr class="separator:aa8b7bfeffb0fa7dc6dbd291fee87edc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cc56e228374b1da0910356b3172b4e"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab5cc56e228374b1da0910356b3172b4e">NvFlexGetRigids</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *offsets, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *restPositions, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *restNormals, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *stiffness, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *thresholds, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *creeps, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *rotations, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *translations)</td></tr>
<tr class="separator:ab5cc56e228374b1da0910356b3172b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdda5a5210938a1e8a7c3a8218ad468e"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#afdda5a5210938a1e8a7c3a8218ad468e">NvFlexCreateTriangleMesh</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:afdda5a5210938a1e8a7c3a8218ad468e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb4462803ebff105d151fd45b4efad6"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a4cb4462803ebff105d151fd45b4efad6">NvFlexDestroyTriangleMesh</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a> mesh)</td></tr>
<tr class="separator:a4cb4462803ebff105d151fd45b4efad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1924ab797971290931b32258b847767"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab1924ab797971290931b32258b847767">NvFlexGetTriangleMeshes</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a> *meshes, int n)</td></tr>
<tr class="separator:ab1924ab797971290931b32258b847767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4958c555f0ed65dee54c37af32529356"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a4958c555f0ed65dee54c37af32529356">NvFlexUpdateTriangleMesh</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a> mesh, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *vertices, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, int numVertices, int numTriangles, const float *lower, const float *upper)</td></tr>
<tr class="separator:a4958c555f0ed65dee54c37af32529356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60794d849b4184335e2a0ddec0a9e6a2"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a60794d849b4184335e2a0ddec0a9e6a2">NvFlexGetTriangleMeshBounds</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, const <a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a> mesh, float *lower, float *upper)</td></tr>
<tr class="separator:a60794d849b4184335e2a0ddec0a9e6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c28caf6d5d513c5adacd4fbc782f308"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a5c28caf6d5d513c5adacd4fbc782f308">NvFlexCreateDistanceField</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:a5c28caf6d5d513c5adacd4fbc782f308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11bdd7f778d17af16cefea33265cb65"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab11bdd7f778d17af16cefea33265cb65">NvFlexDestroyDistanceField</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a> sdf)</td></tr>
<tr class="separator:ab11bdd7f778d17af16cefea33265cb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554d54b930dad17e638ddd30c6dac46f"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a554d54b930dad17e638ddd30c6dac46f">NvFlexGetDistanceFields</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a> *sdfs, int n)</td></tr>
<tr class="separator:a554d54b930dad17e638ddd30c6dac46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584ffb275b9986fd5444ed1a7ea247d9"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a584ffb275b9986fd5444ed1a7ea247d9">NvFlexUpdateDistanceField</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a> sdf, int dimx, int dimy, int dimz, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *field)</td></tr>
<tr class="separator:a584ffb275b9986fd5444ed1a7ea247d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaafe2b1006352002b03aabaca531cc"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#afbaafe2b1006352002b03aabaca531cc">NvFlexCreateConvexMesh</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:afbaafe2b1006352002b03aabaca531cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b6372e5c7bfc508ecb7b8c59c72a0"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ac85b6372e5c7bfc508ecb7b8c59c72a0">NvFlexDestroyConvexMesh</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a> convex)</td></tr>
<tr class="separator:ac85b6372e5c7bfc508ecb7b8c59c72a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa392608715b2304f06606d498bd69312"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aa392608715b2304f06606d498bd69312">NvFlexGetConvexMeshes</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a> *meshes, int n)</td></tr>
<tr class="separator:aa392608715b2304f06606d498bd69312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452c355f92dda050d4b4dafb8e71b03"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab452c355f92dda050d4b4dafb8e71b03">NvFlexUpdateConvexMesh</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a> convex, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *planes, int numPlanes, const float *lower, const float *upper)</td></tr>
<tr class="separator:ab452c355f92dda050d4b4dafb8e71b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56e661161763579afb375b3841eb5ff"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ad56e661161763579afb375b3841eb5ff">NvFlexGetConvexMeshBounds</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, <a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a> mesh, float *lower, float *upper)</td></tr>
<tr class="separator:ad56e661161763579afb375b3841eb5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83b7fb561a91467a3094771bb682b96"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ad83b7fb561a91467a3094771bb682b96">NvFlexMakeShapeFlagsWithChannels</a> (<a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26ba">NvFlexCollisionShapeType</a> type, bool dynamic, int shapeChannels)</td></tr>
<tr class="separator:ad83b7fb561a91467a3094771bb682b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ee1e23e0c49aad63df8f605182de3a"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags</a> (<a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26ba">NvFlexCollisionShapeType</a> type, bool dynamic)</td></tr>
<tr class="separator:ad6ee1e23e0c49aad63df8f605182de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4e7117722df53dfe44c676496117fa"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aea4e7117722df53dfe44c676496117fa">NvFlexSetShapes</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *geometry, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *shapePositions, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *shapeRotations, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *shapePrevPositions, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *shapePrevRotations, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *shapeFlags, int numShapes)</td></tr>
<tr class="separator:aea4e7117722df53dfe44c676496117fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03d94be697cdc3aaa56e469d87255a4"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aa03d94be697cdc3aaa56e469d87255a4">NvFlexSetDynamicTriangles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *normals, int numTris)</td></tr>
<tr class="separator:aa03d94be697cdc3aaa56e469d87255a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfd0834422dd99154a27962614525e5"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#abdfd0834422dd99154a27962614525e5">NvFlexGetDynamicTriangles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *normals, int numTris)</td></tr>
<tr class="separator:abdfd0834422dd99154a27962614525e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2b59fba77c60ce116e1eac57d63e50"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a7f2b59fba77c60ce116e1eac57d63e50">NvFlexSetInflatables</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *startTris, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *numTris, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *restVolumes, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *overPressures, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *constraintScales, int numInflatables)</td></tr>
<tr class="separator:a7f2b59fba77c60ce116e1eac57d63e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a20cc2539983a009caaf77ec9ceab82"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a3a20cc2539983a009caaf77ec9ceab82">NvFlexGetDensities</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *densities, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:a3a20cc2539983a009caaf77ec9ceab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef768edc8e4df1a78a94a6c971541550"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aef768edc8e4df1a78a94a6c971541550">NvFlexGetAnisotropy</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *q1, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *q2, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *q3, const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *desc)</td></tr>
<tr class="separator:aef768edc8e4df1a78a94a6c971541550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa458a6eec8b0d117e53c40c13788fd9"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#afa458a6eec8b0d117e53c40c13788fd9">NvFlexGetDiffuseParticles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *p, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *v, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *count)</td></tr>
<tr class="separator:afa458a6eec8b0d117e53c40c13788fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7213593dd9a23d9d67f8517d1da9de"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a5a7213593dd9a23d9d67f8517d1da9de">NvFlexSetDiffuseParticles</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *p, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *v, int n)</td></tr>
<tr class="separator:a5a7213593dd9a23d9d67f8517d1da9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edac9cf450917147b83e98f5cb09f5d"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a7edac9cf450917147b83e98f5cb09f5d">NvFlexGetContacts</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *planes, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *velocities, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *indices, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *counts)</td></tr>
<tr class="separator:a7edac9cf450917147b83e98f5cb09f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbee38b5413bbfd1db914c66fcdfc616"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#abbee38b5413bbfd1db914c66fcdfc616">NvFlexGetNeighbors</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *neighbors, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *counts, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *apiToInternal, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *internalToApi)</td></tr>
<tr class="separator:abbee38b5413bbfd1db914c66fcdfc616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eec84a21b1872fba11c9b4cc1d1629"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab1eec84a21b1872fba11c9b4cc1d1629">NvFlexGetBounds</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *lower, <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *upper)</td></tr>
<tr class="separator:ab1eec84a21b1872fba11c9b4cc1d1629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77d2a4edd4ccd79c9389854dca80613"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aa77d2a4edd4ccd79c9389854dca80613">NvFlexGetDeviceLatency</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, unsigned long long *begin, unsigned long long *end, unsigned long long *frequency)</td></tr>
<tr class="separator:aa77d2a4edd4ccd79c9389854dca80613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16b6d2e11e0ab417ee6c4cf16f0a27d"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab16b6d2e11e0ab417ee6c4cf16f0a27d">NvFlexGetTimers</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#struct_nv_flex_timers">NvFlexTimers</a> *timers)</td></tr>
<tr class="separator:ab16b6d2e11e0ab417ee6c4cf16f0a27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1efb6764f65900cb09f0188ad6da08a"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab1efb6764f65900cb09f0188ad6da08a">NvFlexGetDetailTimers</a> (<a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *solver, <a class="el" href="_nv_flex_8h.html#struct_nv_flex_detail_timer">NvFlexDetailTimer</a> **timers)</td></tr>
<tr class="separator:ab1efb6764f65900cb09f0188ad6da08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48f83b8442323687d2268206e913496"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, int elementCount, int elementByteStride, <a class="el" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3">NvFlexBufferType</a> type)</td></tr>
<tr class="separator:ad48f83b8442323687d2268206e913496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab559759820a4322aff061745ef26c867"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab559759820a4322aff061745ef26c867">NvFlexFreeBuffer</a> (<a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *buf)</td></tr>
<tr class="separator:ab559759820a4322aff061745ef26c867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0898bb9210440b159688d4647f6eb083"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap</a> (<a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *buffer, int flags)</td></tr>
<tr class="separator:a0898bb9210440b159688d4647f6eb083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054cb27646a389ea257d1bbde46a6e97"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a054cb27646a389ea257d1bbde46a6e97">NvFlexUnmap</a> (<a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *buffer)</td></tr>
<tr class="separator:a054cb27646a389ea257d1bbde46a6e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab83daf46e5a9428a0ad76fb75e8ec7e"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#aab83daf46e5a9428a0ad76fb75e8ec7e">NvFlexRegisterOGLBuffer</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, int buf, int elementCount, int elementByteStride)</td></tr>
<tr class="separator:aab83daf46e5a9428a0ad76fb75e8ec7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78045a8d4e856372df108dc616a94cd8"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a78045a8d4e856372df108dc616a94cd8">NvFlexUnregisterOGLBuffer</a> (<a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *buf)</td></tr>
<tr class="separator:a78045a8d4e856372df108dc616a94cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab487e68ce1c84ce1eec0c85b7daf5aa0"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ab487e68ce1c84ce1eec0c85b7daf5aa0">NvFlexRegisterD3DBuffer</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, void *buffer, int elementCount, int elementByteStride)</td></tr>
<tr class="separator:ab487e68ce1c84ce1eec0c85b7daf5aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad607e7916e5d76b384a61f1c1f94ab32"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ad607e7916e5d76b384a61f1c1f94ab32">NvFlexUnregisterD3DBuffer</a> (<a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *buf)</td></tr>
<tr class="separator:ad607e7916e5d76b384a61f1c1f94ab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ec7b30c79d4733e6a756b5d9b15ee6"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a42ec7b30c79d4733e6a756b5d9b15ee6">NvFlexAcquireContext</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:a42ec7b30c79d4733e6a756b5d9b15ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6671f352bd77e296609d0bc2a57fd11"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#ae6671f352bd77e296609d0bc2a57fd11">NvFlexRestoreContext</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:ae6671f352bd77e296609d0bc2a57fd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c451971259524c6878b6b1ed4023ada"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a4c451971259524c6878b6b1ed4023ada">NvFlexGetDeviceName</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:a4c451971259524c6878b6b1ed4023ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac0a898a565a2cdf13b80acd4a3555c"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a2ac0a898a565a2cdf13b80acd4a3555c">NvFlexGetDeviceAndContext</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib, void **device, void **context)</td></tr>
<tr class="separator:a2ac0a898a565a2cdf13b80acd4a3555c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898eb8e66a456dd2266c694f29cab600"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a898eb8e66a456dd2266c694f29cab600">NvFlexFlush</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:a898eb8e66a456dd2266c694f29cab600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615d2e6eec2486a5db815d929f9c642c"><td class="memItemLeft" align="right" valign="top">NV_FLEX_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_flex_8h.html#a615d2e6eec2486a5db815d929f9c642c">NvFlexWait</a> (<a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *lib)</td></tr>
<tr class="separator:a615d2e6eec2486a5db815d929f9c642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main include file for the core Flex solver. </p>
</div><hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_nv_flex_params" id="struct_nv_flex_params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexParams</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Simulation parameters for a solver </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a572c9bf93128466e27d57f225f4d0188"></a>int</td>
<td class="fieldname">
numIterations</td>
<td class="fielddoc">
Number of solver iterations to perform per-substep. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a482a7c3b197c4df656e9509fbd04032c"></a>float</td>
<td class="fieldname">
gravity[3]</td>
<td class="fielddoc">
Constant acceleration applied to all particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa6eddaa3a6eb35917c093dcabf69a200"></a>float</td>
<td class="fieldname">
radius</td>
<td class="fielddoc">
The maximum interaction radius for particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab7c54d6c0b3d3595780e5179bf62ebc4"></a>float</td>
<td class="fieldname">
solidRestDistance</td>
<td class="fielddoc">
The distance non-fluid particles attempt to maintain from each other, must be in the range (0, radius]. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad019ad1901bc33d43e3a60df0dfe9b09"></a>float</td>
<td class="fieldname">
fluidRestDistance</td>
<td class="fielddoc">
The distance fluid particles are spaced at the rest density, must be in the range (0, radius], for fluids this should generally be 50-70% of mRadius, for rigids this can simply be the same as the particle radius. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a27a185172ad1951d40c476ade8307068"></a>float</td>
<td class="fieldname">
dynamicFriction</td>
<td class="fielddoc">
Coefficient of friction used when colliding against shapes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af0a34fd0cdf686022650be9f895cbf2f"></a>float</td>
<td class="fieldname">
staticFriction</td>
<td class="fielddoc">
Coefficient of static friction used when colliding against shapes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af7a56fc54644e7020e105f2ff41dfb60"></a>float</td>
<td class="fieldname">
particleFriction</td>
<td class="fielddoc">
Coefficient of friction used when colliding particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afc306cb48c313ee518461d60c1014485"></a>float</td>
<td class="fieldname">
restitution</td>
<td class="fielddoc">
Coefficient of restitution used when colliding against shapes, particle collisions are always inelastic. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8114a049f5e16f7d1b960f3ac4993fdb"></a>float</td>
<td class="fieldname">
adhesion</td>
<td class="fielddoc">
Controls how strongly particles stick to surfaces they hit, default 0.0, range [0.0, +inf]. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a533a78227b462a268c905f9c307c4bd6"></a>float</td>
<td class="fieldname">
sleepThreshold</td>
<td class="fielddoc">
Particles with a velocity magnitude &lt; this threshold will be considered fixed. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab003c023dde289dee075c49db022ccaf"></a>float</td>
<td class="fieldname">
maxSpeed</td>
<td class="fielddoc">
The magnitude of particle velocity will be clamped to this value at the end of each step. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0def9c3ceff57bbae5bcec15f6d64b36"></a>float</td>
<td class="fieldname">
maxAcceleration</td>
<td class="fielddoc">
The magnitude of particle acceleration will be clamped to this value at the end of each step (limits max velocity change per-second), useful to avoid popping due to large interpenetrations. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab98a2aba477ab4d4178bf677852bf544"></a>float</td>
<td class="fieldname">
shockPropagation</td>
<td class="fielddoc">
Artificially decrease the mass of particles based on height from a fixed reference point, this makes stacks and piles converge faster. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aeff62427426510eeb1cf5625e14ff585"></a>float</td>
<td class="fieldname">
dissipation</td>
<td class="fielddoc">
Damps particle velocity based on how many particle contacts it has. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a6198445df7f341ec75f37e1dfb44830c"></a>float</td>
<td class="fieldname">
damping</td>
<td class="fielddoc">
Viscous drag force, applies a force proportional, and opposite to the particle velocity. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aafb92c4fa45ce9614cdfd349b3722c8a"></a>float</td>
<td class="fieldname">
wind[3]</td>
<td class="fielddoc">
Constant acceleration applied to particles that belong to dynamic triangles, drag needs to be &gt; 0 for wind to affect triangles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7043181449aebf540351d1d2f785cf4a"></a>float</td>
<td class="fieldname">
drag</td>
<td class="fielddoc">
Drag force applied to particles belonging to dynamic triangles, proportional to velocity^2*area in the negative velocity direction. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af9bb710afb22ec5ed50679aef8717777"></a>float</td>
<td class="fieldname">
lift</td>
<td class="fielddoc">
Lift force applied to particles belonging to dynamic triangles, proportional to velocity^2*area in the direction perpendicular to velocity and (if possible), parallel to the plane normal. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3ef4d1035530c3583bdf983c7e62b472"></a>float</td>
<td class="fieldname">
cohesion</td>
<td class="fielddoc">
Control how strongly particles hold each other together, default: 0.025, range [0.0, +inf]. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5628f890f4ae070e405feaf1f81a7b85"></a>float</td>
<td class="fieldname">
surfaceTension</td>
<td class="fielddoc">
Controls how strongly particles attempt to minimize surface area, default: 0.0, range: [0.0, +inf]. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a40f452b4edbf11b793f31286a0ae270e"></a>float</td>
<td class="fieldname">
viscosity</td>
<td class="fielddoc">
Smoothes particle velocities using XSPH viscosity. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae763dd9bfcfa4092c0165a506e32e18b"></a>float</td>
<td class="fieldname">
vorticityConfinement</td>
<td class="fielddoc">
Increases vorticity by applying rotational forces to particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a608af97e77a912e959b0e825082a9cd6"></a>float</td>
<td class="fieldname">
anisotropyScale</td>
<td class="fielddoc">
Control how much anisotropy is present in resulting ellipsoids for rendering, if zero then anisotropy will not be calculated, see <a class="el" href="_nv_flex_8h.html#aef768edc8e4df1a78a94a6c971541550">NvFlexGetAnisotropy()</a> </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab136ae1511a39ef570c010f321eff206"></a>float</td>
<td class="fieldname">
anisotropyMin</td>
<td class="fielddoc">
Clamp the anisotropy scale to this fraction of the radius. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5e37444b8c96e0880a428d9ea58dbf54"></a>float</td>
<td class="fieldname">
anisotropyMax</td>
<td class="fielddoc">
Clamp the anisotropy scale to this fraction of the radius. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac017e05107d0362d3d03a14eaadf0657"></a>float</td>
<td class="fieldname">
smoothing</td>
<td class="fielddoc">
Control the strength of Laplacian smoothing in particles for rendering, if zero then smoothed positions will not be calculated, see <a class="el" href="_nv_flex_8h.html#a96a771dd328d019e6164e5f23d29ffcb">NvFlexGetSmoothParticles()</a> </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3f93fba688338576ff3258b034525dc5"></a>float</td>
<td class="fieldname">
solidPressure</td>
<td class="fielddoc">
Add pressure from solid surfaces to particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a05f92015449662f5a2f5d5e9ecdc2c6e"></a>float</td>
<td class="fieldname">
freeSurfaceDrag</td>
<td class="fielddoc">
Drag force applied to boundary fluid particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae2e480822cc06ec249ee2557f6cc8ee1"></a>float</td>
<td class="fieldname">
buoyancy</td>
<td class="fielddoc">
Gravity is scaled by this value for fluid particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acdde802d58e1558c03e449e04ae33f15"></a>float</td>
<td class="fieldname">
diffuseThreshold</td>
<td class="fielddoc">
Particles with kinetic energy + divergence above this threshold will spawn new diffuse particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5be673031b100c3861fd9eb824fcf00f"></a>float</td>
<td class="fieldname">
diffuseBuoyancy</td>
<td class="fielddoc">
Scales force opposing gravity that diffuse particles receive. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a4bf0ccff128c165560dba52afb748d7e"></a>float</td>
<td class="fieldname">
diffuseDrag</td>
<td class="fielddoc">
Scales force diffuse particles receive in direction of neighbor fluid particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7ade7491cd0693a6d7c5e88a99298378"></a>int</td>
<td class="fieldname">
diffuseBallistic</td>
<td class="fielddoc">
The number of neighbors below which a diffuse particle is considered ballistic. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a469950744e0b7222969762a89b992255"></a>float</td>
<td class="fieldname">
diffuseLifetime</td>
<td class="fielddoc">
Time in seconds that a diffuse particle will live for after being spawned, particles will be spawned with a random lifetime in the range [0, diffuseLifetime]. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a55bf1f547086b8e469f2c3b20c9ae39d"></a>float</td>
<td class="fieldname">
collisionDistance</td>
<td class="fielddoc">
Distance particles maintain against shapes, note that for robust collision against triangle meshes this distance should be greater than zero. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aeecd11525503649b579ae262b671fbc8"></a>float</td>
<td class="fieldname">
particleCollisionMargin</td>
<td class="fielddoc">
Increases the radius used during neighbor finding, this is useful if particles are expected to move significantly during a single step to ensure contacts aren't missed on subsequent iterations. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0e4cb2f91d3b7d122000d36a7d67ab81"></a>float</td>
<td class="fieldname">
shapeCollisionMargin</td>
<td class="fielddoc">
Increases the radius used during contact finding against kinematic shapes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae54ff0cacfedd4333aa1a1f9b9291906"></a>float</td>
<td class="fieldname">
planes[8][4]</td>
<td class="fielddoc">
Collision planes in the form ax + by + cz + d = 0. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab4f2eb16c8aba6371fbae51a991eaaa5"></a>int</td>
<td class="fieldname">
numPlanes</td>
<td class="fielddoc">
Num collision planes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac2f8dff9857a86683aa6e55c058888d7"></a><a class="el" href="_nv_flex_8h.html#a46f5d35902f7da40628247175a174f3b">NvFlexRelaxationMode</a></td>
<td class="fieldname">
relaxationMode</td>
<td class="fielddoc">
How the relaxation is applied inside the solver. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8a1b3c24aa73606bcd47a72473db9629"></a>float</td>
<td class="fieldname">
relaxationFactor</td>
<td class="fielddoc">
Control the convergence rate of the parallel solver, default: 1, values greater than 1 may lead to instability. </td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_timers" id="struct_nv_flex_timers"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexTimers</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Time spent in each section of the solver update, times in GPU seconds, see <a class="el" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver()</a> </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aaf8baa00e709ff8fd40d114f00bee0b6"></a>float</td>
<td class="fieldname">
predict</td>
<td class="fielddoc">
Time spent in prediction. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aba34bc2bc8736e3a0cf18a7a6b56ff68"></a>float</td>
<td class="fieldname">
createCellIndices</td>
<td class="fielddoc">
Time spent creating grid indices. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae45cb18deec2db8ff44d181e80f24695"></a>float</td>
<td class="fieldname">
sortCellIndices</td>
<td class="fielddoc">
Time spent sorting grid indices. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a98b4df3721709c862ef5d09edcc6d4c3"></a>float</td>
<td class="fieldname">
createGrid</td>
<td class="fielddoc">
Time spent creating grid. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a6071050991cf71a8d9ff28ea968479af"></a>float</td>
<td class="fieldname">
reorder</td>
<td class="fielddoc">
Time spent reordering particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac1f3c3a1eeeb57cf5b20d030a788e25c"></a>float</td>
<td class="fieldname">
collideParticles</td>
<td class="fielddoc">
Time spent finding particle neighbors. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae4203fb9cf4772c3186f96cc2d9f6ea8"></a>float</td>
<td class="fieldname">
collideShapes</td>
<td class="fielddoc">
Time spent colliding convex shapes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afc20d27121f49b61be9cc6bd4c25f547"></a>float</td>
<td class="fieldname">
collideTriangles</td>
<td class="fielddoc">
Time spent colliding triangle shapes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aaa36ba5ee44e34e762167fb0b8b3292e"></a>float</td>
<td class="fieldname">
collideFields</td>
<td class="fielddoc">
Time spent colliding signed distance field shapes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a49f7117a457a716e7790904209f68707"></a>float</td>
<td class="fieldname">
calculateDensity</td>
<td class="fielddoc">
Time spent calculating fluid density. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abe52b62e7af361f387d67414b9e2cf9b"></a>float</td>
<td class="fieldname">
solveDensities</td>
<td class="fielddoc">
Time spent solving density constraints. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a4d10188e917ae045e0e903f3db1c638d"></a>float</td>
<td class="fieldname">
solveVelocities</td>
<td class="fielddoc">
Time spent solving velocity constraints. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abdd60b0a83674283d09b4897fdd637a2"></a>float</td>
<td class="fieldname">
solveShapes</td>
<td class="fielddoc">
Time spent solving rigid body constraints. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a57e4d27b0aa8774e479fa66d65079f78"></a>float</td>
<td class="fieldname">
solveSprings</td>
<td class="fielddoc">
Time spent solving distance constraints. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a215e06106ec0cdbbcd405055a4535d1d"></a>float</td>
<td class="fieldname">
solveContacts</td>
<td class="fielddoc">
Time spent solving contact constraints. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a75eade1512d023cb19da5b7ebbad10f3"></a>float</td>
<td class="fieldname">
solveInflatables</td>
<td class="fielddoc">
Time spent solving pressure constraints. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afc5d58e7f591213c3fe1c31b4d440eb6"></a>float</td>
<td class="fieldname">
applyDeltas</td>
<td class="fielddoc">
Time spent adding position deltas to particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af9b72d2909ef335b12a46cdbd4b71f57"></a>float</td>
<td class="fieldname">
calculateAnisotropy</td>
<td class="fielddoc">
Time spent calculating particle anisotropy for fluid. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2ff723870a6eba26d9f3bb7e5250b27f"></a>float</td>
<td class="fieldname">
updateDiffuse</td>
<td class="fielddoc">
Time spent updating diffuse particles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8cb34cbcf9def6817d6d5d3c07177052"></a>float</td>
<td class="fieldname">
updateTriangles</td>
<td class="fielddoc">
Time spent updating dynamic triangles. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1a1e69f26e02e8b3fca1d3636a7f3f13"></a>float</td>
<td class="fieldname">
updateNormals</td>
<td class="fielddoc">
Time spent updating vertex normals. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9d825db54bc9a0bca998b3654db3b20e"></a>float</td>
<td class="fieldname">
finalize</td>
<td class="fielddoc">
Time spent finalizing state. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2f85189cbc3014b73164cf8c4eb87e0a"></a>float</td>
<td class="fieldname">
updateBounds</td>
<td class="fielddoc">
Time spent updating particle bounds. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3c4d2aa395ff8d0f70a6380448943be2"></a>float</td>
<td class="fieldname">
total</td>
<td class="fielddoc">
Sum of all timers above. </td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_solver_callback_params" id="struct_nv_flex_solver_callback_params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexSolverCallbackParams</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure containing pointers to the internal solver data that is passed to each registered solver callback</p>
<dl class="section remark"><dt>Remarks</dt><dd>Pointers to internal data are only valid for the lifetime of the callback and should not be stored. However, it is safe to launch kernels and memory transfers using the device pointers.</dd>
<dd>
Because Flex re-orders particle data internally for performance, the particle data in the callback is not in the same order as it was provided to the API. The callback provides arrays which map original particle indices to sorted positions and vice-versa.</dd>
<dd>
Particle positions may be modified during any callback, but velocity modifications should only occur during the eNvFlexStageUpdateEnd stage, otherwise any velocity changes will be discarded. </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3974e1e608d9f532d5520dc158b47903"></a><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *</td>
<td class="fieldname">
solver</td>
<td class="fielddoc">
Pointer to the solver that the callback is registered to. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5b9af9cf4d889b4772cb61cefda92a87"></a>void *</td>
<td class="fieldname">
userData</td>
<td class="fielddoc">
Pointer to the user data provided to <a class="el" href="_nv_flex_8h.html#ac5427457488ab3f2de91cf65335dda08">NvFlexRegisterSolverCallback()</a> </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8ed42f9bd016cbcef45c96b5b32ca609"></a>float *</td>
<td class="fieldname">
particles</td>
<td class="fielddoc">
Device pointer to the active particle basic data in the form x,y,z,1/m. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac48a490fa3d62cc678c309dd4b8cbf18"></a>float *</td>
<td class="fieldname">
velocities</td>
<td class="fielddoc">
Device pointer to the active particle velocity data in the form x,y,z,w (last component is not used) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9e5f943053d43d7e1a6b149babe4fe44"></a>int *</td>
<td class="fieldname">
phases</td>
<td class="fielddoc">
Device pointer to the active particle phase data. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac32019f7dd1f30ab8a7391a417ed02c9"></a>int</td>
<td class="fieldname">
numActive</td>
<td class="fielddoc">
The number of active particles returned, the callback data only return pointers to active particle data, this is the same as <a class="el" href="_nv_flex_8h.html#a2345372dea2ad4f043153a84e7a2c407">NvFlexGetActiveCount()</a> </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a843360ebf23cd00e5eff72d19e796dd9"></a>float</td>
<td class="fieldname">
dt</td>
<td class="fielddoc">
The per-update time-step, this is the value passed to <a class="el" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver()</a> </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abe564dbbbd4957542322b60d77a70e29"></a>const int *</td>
<td class="fieldname">
originalToSortedMap</td>
<td class="fielddoc">
Device pointer that maps the sorted callback data to the original position given by SetParticles() </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9b65813d2a2d3f99db162d39a62481f8"></a>const int *</td>
<td class="fieldname">
sortedToOriginalMap</td>
<td class="fielddoc">
Device pointer that maps the original particle index to the index in the callback data structure. </td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_init_desc" id="struct_nv_flex_init_desc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexInitDesc</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Descriptor used to initialize Flex </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5890b9e46d626cfa19994976ea53c52e"></a>int</td>
<td class="fieldname">
deviceIndex</td>
<td class="fielddoc">
The GPU device index that should be used, if there is already a CUDA context on the calling thread then this parameter will be ignored and the active CUDA context used. Otherwise a new context will be created using the suggested device ordinal. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a23b8779c1516647ef5ed7f8010d619ff"></a>bool</td>
<td class="fieldname">
enableExtensions</td>
<td class="fielddoc">
Enable or disable NVIDIA/AMD extensions in DirectX, can lead to improved performance. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7e760844341b78a547ca4e29abf48806"></a>void *</td>
<td class="fieldname">
renderDevice</td>
<td class="fielddoc">
Direct3D device to use for simulation, if none is specified a new device and context will be created. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abf304d5c1f8f041fa46a2bfb0bdf56fe"></a>void *</td>
<td class="fieldname">
renderContext</td>
<td class="fielddoc">
Direct3D context that the app is using for rendering. In DirectX 12 this should be a ID3D12CommandQueue pointer. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad1d0256dac295346120fda40f6eea7e2"></a>void *</td>
<td class="fieldname">
computeContext</td>
<td class="fielddoc">
Direct3D context to use for simulation, if none is specified a new context will be created, in DirectX 12 this should be a pointer to the ID3D12CommandQueue where compute operations will take place. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad9503e8b23e084c0f940be3dcca9af2e"></a>bool</td>
<td class="fieldname">
runOnRenderContext</td>
<td class="fielddoc">
If true, run Flex on D3D11 render context, or D3D12 direct queue. If false, run on a D3D12 compute queue, or vendor specific D3D11 compute queue, allowing compute and graphics to run in parallel on some GPUs. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aeeeaf91dad0804d1dd3125e592a3260b"></a><a class="el" href="_nv_flex_8h.html#a9b2d3dc5ac42011aeec4e13be2e14252">NvFlexComputeType</a></td>
<td class="fieldname">
computeType</td>
<td class="fielddoc">
Set to eNvFlexD3D11 if DirectX 11 should be used, eNvFlexD3D12 for DirectX 12, this must match the libraries used to link the application. </td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_solver_desc" id="struct_nv_flex_solver_desc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexSolverDesc</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Describes the creation time parameters for the solver </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0999d825c8760e19ba4c980d2eb097ac"></a><a class="el" href="_nv_flex_8h.html#aee5c235d5fab40831cf339680aa25560">NvFlexFeatureMode</a></td>
<td class="fieldname">
featureMode</td>
<td class="fielddoc">
Control which features are enabled. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aedf73c7aa1f4df92c7724d58f4dcb266"></a>int</td>
<td class="fieldname">
maxParticles</td>
<td class="fielddoc">
Maximum number of regular particles in the solver. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a39ab69ac3fbde631b71f59f5bbbf1bdf"></a>int</td>
<td class="fieldname">
maxDiffuseParticles</td>
<td class="fielddoc">
Maximum number of diffuse particles in the solver. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5ea0cd160a13a72924340184edfbea2f"></a>int</td>
<td class="fieldname">
maxNeighborsPerParticle</td>
<td class="fielddoc">
Maximum number of neighbors per-particle, for solids this can be around 32, for fluids up to 128 may be necessary depending on smoothing radius. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a97d23c69cd4f343be14dedd911605276"></a>int</td>
<td class="fieldname">
maxContactsPerParticle</td>
<td class="fielddoc">
Maximum number of collision contacts per-particle. </td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_copy_desc" id="struct_nv_flex_copy_desc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexCopyDesc</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Describes a source and destination buffer region for performing a copy operation. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae01bc8c45cf48f5faed2a8e78df1c678"></a>int</td>
<td class="fieldname">
srcOffset</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa544809448a95c3864e1443c7a507d7f"></a>int</td>
<td class="fieldname">
dstOffset</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af842f041f92c608b3ebfa2092caea889"></a>int</td>
<td class="fieldname">
elementCount</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_sphere_geometry" id="struct_nv_flex_sphere_geometry"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexSphereGeometry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A basic sphere shape with origin at the center of the sphere and radius </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7a6e24c01235abc364ed12570ab15f84"></a>float</td>
<td class="fieldname">
radius</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_capsule_geometry" id="struct_nv_flex_capsule_geometry"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexCapsuleGeometry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A collision capsule extends along the x-axis with its local origin at the center of the capsule </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1241ff3522eafac4b402370a7a6525d8"></a>float</td>
<td class="fieldname">
radius</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aef1b5bceccca709ebb782d2ea8a61dc9"></a>float</td>
<td class="fieldname">
halfHeight</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_box_geometry" id="struct_nv_flex_box_geometry"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexBoxGeometry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A simple box with interior [-halfHeight, +halfHeight] along each dimension </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab669c404607156367b09878870dbe30c"></a>float</td>
<td class="fieldname">
halfExtents[3]</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_convex_mesh_geometry" id="struct_nv_flex_convex_mesh_geometry"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexConvexMeshGeometry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A convex mesh instance with non-uniform scale </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a800620cc4888bbe5696c5f0e19b22bb9"></a>float</td>
<td class="fieldname">
scale[3]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abdc984644770fec15d7af740c9730186"></a><a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a></td>
<td class="fieldname">
mesh</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_triangle_mesh_geometry" id="struct_nv_flex_triangle_mesh_geometry"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexTriangleMeshGeometry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A scaled triangle mesh instance with non-uniform scale </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab6e2aa06b69e92cbd3b2bca19f18e794"></a>float</td>
<td class="fieldname">
scale[3]</td>
<td class="fielddoc">
The scale of the object from local space to world space. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af6a50e64591866ae2390a57e3342566c"></a><a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a></td>
<td class="fieldname">
mesh</td>
<td class="fielddoc">
A triangle mesh pointer created by <a class="el" href="_nv_flex_8h.html#afdda5a5210938a1e8a7c3a8218ad468e">NvFlexCreateTriangleMesh()</a> </td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_s_d_f_geometry" id="struct_nv_flex_s_d_f_geometry"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexSDFGeometry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A scaled signed distance field instance, the local origin of the SDF is at corner of the field corresponding to the first voxel. The field is mapped to the local space volume [0, 1] in each dimension. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0008a52f6ae1e17c436b095549bf1c78"></a>float</td>
<td class="fieldname">
scale</td>
<td class="fielddoc">
Uniform scale of SDF, this corresponds to the world space width of the shape. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0a6936f3cb0544ad624f1dea6b7eb50c"></a><a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a></td>
<td class="fieldname">
field</td>
<td class="fielddoc">
A signed distance field pointer created by <a class="el" href="_nv_flex_8h.html#a5c28caf6d5d513c5adacd4fbc782f308">NvFlexCreateDistanceField()</a> </td></tr>
</table>

</div>
</div>
<a name="union_nv_flex_collision_geometry" id="union_nv_flex_collision_geometry"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union NvFlexCollisionGeometry</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This union allows collision geometry to be sent to Flex as a flat array of 16-byte data structures, the shape flags array specifies the type for each shape, see <a class="el" href="_nv_flex_8h.html#aea4e7117722df53dfe44c676496117fa">NvFlexSetShapes()</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0e3c0e02ec7addd25ebb3355a8865bfb"></a><a class="el" href="_nv_flex_8h.html#struct_nv_flex_sphere_geometry">NvFlexSphereGeometry</a></td>
<td class="fieldname">
sphere</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8ad5aa3c9c9456607de9a2c9f1d0d2c1"></a><a class="el" href="_nv_flex_8h.html#struct_nv_flex_capsule_geometry">NvFlexCapsuleGeometry</a></td>
<td class="fieldname">
capsule</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a53e827707abaf2e03b78c3c88469d7bf"></a><a class="el" href="_nv_flex_8h.html#struct_nv_flex_box_geometry">NvFlexBoxGeometry</a></td>
<td class="fieldname">
box</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae701fdcc0e7bf26c1dfc54d400ffb3d2"></a><a class="el" href="_nv_flex_8h.html#struct_nv_flex_convex_mesh_geometry">NvFlexConvexMeshGeometry</a></td>
<td class="fieldname">
convexMesh</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a064e3ce30320610d495ba3faa72dc8d6"></a><a class="el" href="_nv_flex_8h.html#struct_nv_flex_triangle_mesh_geometry">NvFlexTriangleMeshGeometry</a></td>
<td class="fieldname">
triMesh</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac0049037dcff7a769030acd567eac6cd"></a><a class="el" href="_nv_flex_8h.html#struct_nv_flex_s_d_f_geometry">NvFlexSDFGeometry</a></td>
<td class="fieldname">
sdf</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct_nv_flex_detail_timer" id="struct_nv_flex_detail_timer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NvFlexDetailTimer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Holds the execution time for a specfic shader </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3ddbb30a2fde4a2e9ccec7854300b1d4"></a>char *</td>
<td class="fieldname">
name</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a83f6117fe98bc6426027a9b784fd737c"></a>float</td>
<td class="fieldname">
time</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a3078976e98f370a9fbdb11db80f1f318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> <a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque type representing a library that can create FlexSolvers, FlexTriangleMeshes, and NvFlexBuffers </p>

</div>
</div>
<a class="anchor" id="afaeb57f4ee7e54b1ae1b912a465ed39e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> <a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque type representing a collection of particles and constraints </p>

</div>
</div>
<a class="anchor" id="a50a3933d3f7b77d0500c702b1fa9ba9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque type representing a data buffer, type and contents depends on usage, see <a class="el" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer()</a> </p>

</div>
</div>
<a class="anchor" id="abe6f00c9b94debbf7c181082a14076d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* NvFlexErrorCallback) (<a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfca">NvFlexErrorSeverity</a> type, const char *msg, const char *file, int line)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer type for error reporting callbacks </p>

</div>
</div>
<a class="anchor" id="a2aea4c3d772b4dbccb7dd9ba37c1bdc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An opaque type representing a static triangle mesh in the solver </p>

</div>
</div>
<a class="anchor" id="a56e990c5bfbc89677988cbf2471c0ade"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An opaque type representing a signed distance field collision shape in the solver. </p>

</div>
</div>
<a class="anchor" id="a7ab5aa68da7ca1f69211a900f1a1c586"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An opaque type representing a convex mesh collision shape in the solver. Convex mesh shapes may consist of up to 64 planes of the form a*x + b*y + c*z + d = 0, particles will be constrained to the outside of the shape. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a6541b33eaca7b2323e73b30cea34d16c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#a6541b33eaca7b2323e73b30cea34d16c">NvFlexMapFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls behavior of <a class="el" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6541b33eaca7b2323e73b30cea34d16ca11adf517d180983daec217e761acc3d6"></a>eNvFlexMapWait&#160;</td><td class="fielddoc">
<p>Calling thread will be blocked until buffer is ready for access, default. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6541b33eaca7b2323e73b30cea34d16ca1bd450ab65ccc06288fae95e23d5e6f1"></a>eNvFlexMapDoNotWait&#160;</td><td class="fielddoc">
<p>Calling thread will check if buffer is ready for access, if not ready then the method will return NULL immediately. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a169e4c126acf46bdebf76c36a44deca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3">NvFlexBufferType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls memory space of a NvFlexBuffer, see <a class="el" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a169e4c126acf46bdebf76c36a44deca3aec63221ddc1b13eff4db55fbf6cd85f8"></a>eNvFlexBufferHost&#160;</td><td class="fielddoc">
<p>A host mappable buffer, pinned memory on CUDA, staging buffer on DX. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a169e4c126acf46bdebf76c36a44deca3a103255fa795b55a7f430a41493002576"></a>eNvFlexBufferDevice&#160;</td><td class="fielddoc">
<p>A device memory buffer, mapping this on CUDA will return a device memory pointer, and will return a buffer pointer on DX. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a46f5d35902f7da40628247175a174f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#a46f5d35902f7da40628247175a174f3b">NvFlexRelaxationMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the relaxation method used by the solver to ensure convergence </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a46f5d35902f7da40628247175a174f3ba33711a4b466d606d68dee43918f819db"></a>eNvFlexRelaxationGlobal&#160;</td><td class="fielddoc">
<p>The relaxation factor is a fixed multiplier on each constraint's position delta. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46f5d35902f7da40628247175a174f3ba858afe9529e908c2bc8ce92da8943b7c"></a>eNvFlexRelaxationLocal&#160;</td><td class="fielddoc">
<p>The relaxation factor is a fixed multiplier on each constraint's delta divided by the particle's constraint count, convergence will be slower but more reliable. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#a5ad2a7745fcb4d4afd5b5f1bda074644">NvFlexPhase</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags that control a particle's behavior and grouping, use <a class="el" href="_nv_flex_8h.html#ab43db5f28808f8038cfc9330d4b47d57">NvFlexMakePhase()</a> to construct a valid 32bit phase identifier </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644ad108f6ebf28346813cfd3602d984bb32"></a>eNvFlexPhaseGroupMask&#160;</td><td class="fielddoc">
<p>Bits [ 0, 19] represent the particle group for controlling collisions. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a7b776084468bae4e3566484cf34d0154"></a>eNvFlexPhaseFlagsMask&#160;</td><td class="fielddoc">
<p>Bits [20, 23] hold flags about how the particle behave. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644ae4ea43366942f719f40e8526ad21a038"></a>eNvFlexPhaseShapeChannelMask&#160;</td><td class="fielddoc">
<p>Bits [24, 30] hold flags representing what shape collision channels particles will collide with, see <a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags()</a> (highest bit reserved for now) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a453a23cc8e9d2e6097b5be187f3c6977"></a>eNvFlexPhaseSelfCollide&#160;</td><td class="fielddoc">
<p>If set this particle will interact with particles of the same group. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a76a62d3a5df428f18e01f8b37573a7b1"></a>eNvFlexPhaseSelfCollideFilter&#160;</td><td class="fielddoc">
<p>If set this particle will ignore collisions with particles closer than the radius in the rest pose, this flag should not be specified unless valid rest positions have been specified using <a class="el" href="_nv_flex_8h.html#a125cfd9817437bb4f4bcb9418efa3dda">NvFlexSetRestParticles()</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a1728772beb1746ace4c549b2ed8f1d74"></a>eNvFlexPhaseFluid&#160;</td><td class="fielddoc">
<p>If set this particle will generate fluid density constraints for its overlapping neighbors. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a52ee05f3e425c336856277774bc9f69f"></a>eNvFlexPhaseUnused&#160;</td><td class="fielddoc">
<p>Reserved. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a66aa70953a97744621e2afa41d0e32d2"></a>eNvFlexPhaseShapeChannel0&#160;</td><td class="fielddoc">
<p>Particle will collide with shapes with channel 0 set (see <a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a1de4e956764950e501bcb8376a70f5a9"></a>eNvFlexPhaseShapeChannel1&#160;</td><td class="fielddoc">
<p>Particle will collide with shapes with channel 1 set (see <a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644aa3a4fd0d5930b31199334e500ac2d7c8"></a>eNvFlexPhaseShapeChannel2&#160;</td><td class="fielddoc">
<p>Particle will collide with shapes with channel 2 set (see <a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644ab4034dbf78d6045ee13278531ee21c2b"></a>eNvFlexPhaseShapeChannel3&#160;</td><td class="fielddoc">
<p>Particle will collide with shapes with channel 3 set (see <a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644af309316efb695be38a4e15986be21ef9"></a>eNvFlexPhaseShapeChannel4&#160;</td><td class="fielddoc">
<p>Particle will collide with shapes with channel 4 set (see <a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a92bbb75d47ea0058a9a89deb0abec67f"></a>eNvFlexPhaseShapeChannel5&#160;</td><td class="fielddoc">
<p>Particle will collide with shapes with channel 5 set (see <a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5ad2a7745fcb4d4afd5b5f1bda074644a0c8d08e646d2713e34d7e2dd6e7b21f2"></a>eNvFlexPhaseShapeChannel6&#160;</td><td class="fielddoc">
<p>Particle will collide with shapes with channel 6 set (see <a class="el" href="_nv_flex_8h.html#ad6ee1e23e0c49aad63df8f605182de3a">NvFlexMakeShapeFlags()</a>) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab4435b3857752360375fe52fc992cfca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#ab4435b3857752360375fe52fc992cfca">NvFlexErrorSeverity</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flex error return codes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab4435b3857752360375fe52fc992cfcaa8aed6496f033604148138299fa075edd"></a>eNvFlexLogError&#160;</td><td class="fielddoc">
<p>Error messages. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4435b3857752360375fe52fc992cfcaa03d239332ae87f46270855dd06b6e58f"></a>eNvFlexLogInfo&#160;</td><td class="fielddoc">
<p>Information messages. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4435b3857752360375fe52fc992cfcaa5538835c4767004ba5fd443ada08ea61"></a>eNvFlexLogWarning&#160;</td><td class="fielddoc">
<p>Warning messages. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4435b3857752360375fe52fc992cfcaa77b51759e33d60b2caf327bb4835351e"></a>eNvFlexLogDebug&#160;</td><td class="fielddoc">
<p>Used only in debug version of dll. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4435b3857752360375fe52fc992cfcaa8feff72c0b0391e8adf3ddb6c39ef10e"></a>eNvFlexLogAll&#160;</td><td class="fielddoc">
<p>All log types. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4f80c8bcfa6de99a52983adb13d80db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9">NvFlexSolverCallbackStage</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the set of stages at which callbacks may be registered </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4f80c8bcfa6de99a52983adb13d80db9a9f3914fdb03915a14ebe55a2c730e7ff"></a>eNvFlexStageIterationStart&#160;</td><td class="fielddoc">
<p>Called at the beginning of each constraint iteration. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4f80c8bcfa6de99a52983adb13d80db9ab75a912c3990b0fbd6b06a6741a20e69"></a>eNvFlexStageIterationEnd&#160;</td><td class="fielddoc">
<p>Called at the end of each constraint iteration. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4f80c8bcfa6de99a52983adb13d80db9a79ce9005dbc92198a1f180c6afde6a44"></a>eNvFlexStageSubstepBegin&#160;</td><td class="fielddoc">
<p>Called at the beginning of each substep after the prediction step has been completed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4f80c8bcfa6de99a52983adb13d80db9a6f13e2ebdbf21f8c8ebcfe1ac9160586"></a>eNvFlexStageSubstepEnd&#160;</td><td class="fielddoc">
<p>Called at the end of each substep after the velocity has been updated by the constraints. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4f80c8bcfa6de99a52983adb13d80db9a260340ba9071892bd8795c3b29289806"></a>eNvFlexStageUpdateEnd&#160;</td><td class="fielddoc">
<p>Called at the end of solver update after the final substep has completed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4f80c8bcfa6de99a52983adb13d80db9a1f2e7acff9b3b74922f90240d29fd1b3"></a>eNvFlexStageCount&#160;</td><td class="fielddoc">
<p>Number of stages. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9b2d3dc5ac42011aeec4e13be2e14252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#a9b2d3dc5ac42011aeec4e13be2e14252">NvFlexComputeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the different compute backends that Flex can use </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9b2d3dc5ac42011aeec4e13be2e14252ad0c27f7aafdc4fe569722025c8eb2178"></a>eNvFlexCUDA&#160;</td><td class="fielddoc">
<p>Use CUDA compute for Flex, the application must link against the CUDA libraries. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9b2d3dc5ac42011aeec4e13be2e14252a297a93979a88fda6e6b551dcab5fb3df"></a>eNvFlexD3D11&#160;</td><td class="fielddoc">
<p>Use DirectX 11 compute for Flex, the application must link against the D3D libraries. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9b2d3dc5ac42011aeec4e13be2e14252a15e78a7baf13cc7fd73f255ac84f0943"></a>eNvFlexD3D12&#160;</td><td class="fielddoc">
<p>Use DirectX 12 compute for Flex, the application must link against the D3D libraries. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aee5c235d5fab40831cf339680aa25560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#aee5c235d5fab40831cf339680aa25560">NvFlexFeatureMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls which features are enabled, choosing a simple option will disable features and can lead to better performance and reduced memory usage </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aee5c235d5fab40831cf339680aa25560a3ab06dc4cd4aa073ab0f2d96a56c499d"></a>eNvFlexFeatureModeDefault&#160;</td><td class="fielddoc">
<p>All features enabled. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee5c235d5fab40831cf339680aa25560a421fe1e1bb00fc41e9b32208cd9155f5"></a>eNvFlexFeatureModeSimpleSolids&#160;</td><td class="fielddoc">
<p>Simple per-particle collision (no per-particle SDF normals, no fluids) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee5c235d5fab40831cf339680aa25560aeab2b8a68b528d46e11b71ad0f4d83f2"></a>eNvFlexFeatureModeSimpleFluids&#160;</td><td class="fielddoc">
<p>Simple single phase fluid-only particles (no solids) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a0506ae712f846087b8647ea389ac26ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26ba">NvFlexCollisionShapeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0506ae712f846087b8647ea389ac26baae22144512ae098865c6725af16a68ad3"></a>eNvFlexShapeSphere&#160;</td><td class="fielddoc">
<p>A sphere shape, see FlexSphereGeometry. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0506ae712f846087b8647ea389ac26baa1724c140b583fbf2c11c14a24dd3764a"></a>eNvFlexShapeCapsule&#160;</td><td class="fielddoc">
<p>A capsule shape, see FlexCapsuleGeometry. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0506ae712f846087b8647ea389ac26baab17c8dd4f9500016b77a9b49de3c48e7"></a>eNvFlexShapeBox&#160;</td><td class="fielddoc">
<p>A box shape, see FlexBoxGeometry. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0506ae712f846087b8647ea389ac26baaed52f0e803c6745ffc1a5f018a8756ce"></a>eNvFlexShapeConvexMesh&#160;</td><td class="fielddoc">
<p>A convex mesh shape, see FlexConvexMeshGeometry. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0506ae712f846087b8647ea389ac26baa315488da382a5e9794c83358385f7ae1"></a>eNvFlexShapeTriangleMesh&#160;</td><td class="fielddoc">
<p>A triangle mesh shape, see FlexTriangleMeshGeometry. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0506ae712f846087b8647ea389ac26baa1fd78f8694b954f8d12fe7d911f17180"></a>eNvFlexShapeSDF&#160;</td><td class="fielddoc">
<p>A signed distance field shape, see FlexSDFGeometry. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a31c31ea4f96cd4fdadc6b7317691304c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_nv_flex_8h.html#a31c31ea4f96cd4fdadc6b7317691304c">NvFlexCollisionShapeFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a31c31ea4f96cd4fdadc6b7317691304cae8a10737948abf6973f0f1d66bae7ef8"></a>eNvFlexShapeFlagTypeMask&#160;</td><td class="fielddoc">
<p>Lower 3 bits holds the type of the collision shape given by the NvFlexCollisionShapeType enum. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31c31ea4f96cd4fdadc6b7317691304cadc6740cf6d829fba159d92e43ffb5992"></a>eNvFlexShapeFlagDynamic&#160;</td><td class="fielddoc">
<p>Indicates the shape is dynamic and should have lower priority over static collision shapes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31c31ea4f96cd4fdadc6b7317691304ca409215fa9b917f2d0830a66bd11b3ff8"></a>eNvFlexShapeFlagTrigger&#160;</td><td class="fielddoc">
<p>Indicates that the shape is a trigger volume, this means it will not perform any collision response, but will be reported in the contacts array (see <a class="el" href="_nv_flex_8h.html#a7edac9cf450917147b83e98f5cb09f5d">NvFlexGetContacts()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31c31ea4f96cd4fdadc6b7317691304caa1c1225f6b8b2906c83748cfc46b81d9"></a>eNvFlexShapeFlagReserved&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a615e8070212c24a70e7a849120c13353"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexMakePhaseWithChannels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>particleFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shapeChannels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a bit set for the particle phase, this is a helper method to simply combine the group id and bit flags into a single integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>The index of the group for this particle, should be an integer &lt; 2^20 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleFlags</td><td>A combination of the phase flags which should be a combination of eNvFlexPhaseSelfCollide, eNvFlexPhaseSelfCollideFilter, and eNvFlexPhaseFluid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapeChannels</td><td>A combination of eNvFlexPhaseShapeChannel* flags that control which shapes will be collided against, particles will only collide against shapes that share at least one set channel, see <a class="el" href="_nv_flex_8h.html#ad83b7fb561a91467a3094771bb682b96">NvFlexMakeShapeFlagsWithChannels()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab43db5f28808f8038cfc9330d4b47d57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexMakePhase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>particleFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deprecated helper method to generates a phase with all shape channels set </p>

</div>
</div>
<a class="anchor" id="a687e5ec141948f779faa9183b68cb743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a>* NvFlexInit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em> = <code>NV_FLEX_VERSION</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#abe6f00c9b94debbf7c181082a14076d5">NvFlexErrorCallback</a>&#160;</td>
          <td class="paramname"><em>errorFunc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_init_desc">NvFlexInitDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize library, should be called before any other API function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">version</td><td>The version number the app is expecting, should almost always be NV_FLEX_VERSION </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errorFunc</td><td>The callback used for reporting errors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The <a class="el" href="_nv_flex_8h.html#struct_nv_flex_init_desc">NvFlexInitDesc</a> struct defining the device ordinal, D3D device/context and the type of D3D compute being used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a library instance that can be used to allocate shared object such as triangle meshes, buffers, etc </dd></dl>

</div>
</div>
<a class="anchor" id="aaf59e45ada57c7f958a8030099cbe211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexShutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shutdown library, users should manually destroy any previously created solvers to ensure memory is freed before calling this method. If a new CUDA context was created during <a class="el" href="_nv_flex_8h.html#a687e5ec141948f779faa9183b68cb743">NvFlexInit()</a> then it will be destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library intance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac25ec5de38c177db51198bb620644d36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexGetVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get library version number </p>

</div>
</div>
<a class="anchor" id="a69a33d464c002a8916a5925c6ef32ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetSolverDescDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_desc">NvFlexSolverDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the solver desc to its default values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Pointer to a description structure that will be initialized to default values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e925acbc34675dfe247da017cbd855f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a>* NvFlexCreateSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_desc">NvFlexSolverDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new particle solver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Pointer to a solver description structure used to create the solver </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d755d7b090f7ed5c4c50d2d3fef1558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexDestroySolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a particle solver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver pointer created from <a class="el" href="_nv_flex_8h.html#a9e925acbc34675dfe247da017cbd855f">NvFlexCreateSolver()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad53909027df03c6a352746d8ddc088ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexGetSolvers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> **&#160;</td>
          <td class="paramname"><em>solvers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the list of active solvers in the library If the size of the array is smaller than the number of active solvers, only the first n entries are copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solvers</td><td>Pointer to array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of active solvers in the library </dd></dl>

</div>
</div>
<a class="anchor" id="ae0d57e4fc2b3b51ec08f7da0a28ff343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a>* NvFlexGetSolverLibrary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the library associated with a solver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver created with <a class="el" href="_nv_flex_8h.html#a9e925acbc34675dfe247da017cbd855f">NvFlexCreateSolver()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A library pointer </dd></dl>

</div>
</div>
<a class="anchor" id="afd6aff58269d6c359df2453c96397840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetSolverDesc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_desc">NvFlexSolverDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the solver desc that was used to create a solver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>Pointer to a valid Flex solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Pointer to a desc structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5427457488ab3f2de91cf65335dda08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="struct_nv_flex_solver_callback.html">NvFlexSolverCallback</a> NvFlexRegisterSolverCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_flex_solver_callback.html">NvFlexSolverCallback</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a4f80c8bcfa6de99a52983adb13d80db9">NvFlexSolverCallbackStage</a>&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback for a solver stage, the callback will be invoked from the same thread that calls <a class="el" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>A pointer to a function that will be called during the solver update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stage</td><td>The stage of the update at which the callback function will be called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previously registered callback for this slot, this allows multiple users to chain callbacks together </dd></dl>

</div>
</div>
<a class="anchor" id="ac75370f005fd453fe8a324fe62be1b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexUpdateSolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>substeps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableTimers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integrate particle solver forward in time. Below is an example of how to step Flex in the context of a simple game loop:</p>
<div class="fragment"><div class="line"><a class="code" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a>* library = <a class="code" href="_nv_flex_8h.html#a687e5ec141948f779faa9183b68cb743">NvFlexInit</a>();</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a>* solver = <a class="code" href="_nv_flex_8h.html#a9e925acbc34675dfe247da017cbd855f">NvFlexCreateSolver</a>(library);</div>
<div class="line"></div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a>* particleBuffer = <a class="code" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer</a>(library, n, <span class="keyword">sizeof</span>(Vec4), <a class="code" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3aec63221ddc1b13eff4db55fbf6cd85f8">eNvFlexBufferHost</a>);</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a>* velocityBuffer = <a class="code" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer</a>(library, n, <span class="keyword">sizeof</span>(Vec4), <a class="code" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3aec63221ddc1b13eff4db55fbf6cd85f8">eNvFlexBufferHost</a>);</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a>* phaseBuffer = <a class="code" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer</a>(library, n, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), <a class="code" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3aec63221ddc1b13eff4db55fbf6cd85f8">eNvFlexBufferHost</a>);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span>(!done)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// map buffers for reading / writing</span></div>
<div class="line"> float4* particles = (float4*)<a class="code" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap</a>(particles, <a class="code" href="_nv_flex_8h.html#a6541b33eaca7b2323e73b30cea34d16ca11adf517d180983daec217e761acc3d6">eNvFlexMapWait</a>);</div>
<div class="line"> float3* velocities  = (float3*)<a class="code" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap</a>(velocities, <a class="code" href="_nv_flex_8h.html#a6541b33eaca7b2323e73b30cea34d16ca11adf517d180983daec217e761acc3d6">eNvFlexMapWait</a>);</div>
<div class="line"> <span class="keywordtype">int</span>* phases = (<span class="keywordtype">int</span>*)<a class="code" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap</a>(phases, <a class="code" href="_nv_flex_8h.html#a6541b33eaca7b2323e73b30cea34d16ca11adf517d180983daec217e761acc3d6">eNvFlexMapWait</a>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// spawn (user method)</span></div>
<div class="line"> SpawnParticles(particles, velocities, phases);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// render (user method)</span></div>
<div class="line"> RenderParticles(particles, velocities, phases);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// unmap buffers</span></div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#a054cb27646a389ea257d1bbde46a6e97">NvFlexUnmap</a>(particleBuffer);</div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#a054cb27646a389ea257d1bbde46a6e97">NvFlexUnmap</a>(velocityBuffer);</div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#a054cb27646a389ea257d1bbde46a6e97">NvFlexUnmap</a>(phaseBuffer);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write to device (async)</span></div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#a7ec5ebe3e98a44a2058d6be74b2cb633">NvFlexSetParticles</a>(particleBuffer, n);</div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#ae2b271f123db0054512936f2acc6467f">NvFlexSetVelocities</a>(velocityBuffer, n);</div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#aa1d44495e442f8cae874c635ef847478">NvFlexSetPhases</a>(phaseBuffer, n);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// tick</span></div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver</a>(solver, dt, 1, NULL);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read back (async)</span></div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#aaff62cfd50431d82af5d04a6c9ac4ffd">NvFlexGetParticles</a>(particleBuffer, n);</div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#afbcbff4e4865105514c194398ab3a7b0">NvFlexGetVelocities</a>(velocityBuffer, n);</div>
<div class="line"> <a class="code" href="_nv_flex_8h.html#accc944f0e76ee2e5d67c3f977b150806">NvFlexGetPhases</a>(phaseBuffer, n);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="_nv_flex_8h.html#ab559759820a4322aff061745ef26c867">NvFlexFreeBuffer</a>(particleBuffer);</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#ab559759820a4322aff061745ef26c867">NvFlexFreeBuffer</a>(velocityBuffer);</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#ab559759820a4322aff061745ef26c867">NvFlexFreeBuffer</a>(phaseBuffer);</div>
<div class="line"></div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a1d755d7b090f7ed5c4c50d2d3fef1558">NvFlexDestroySolver</a>(solver);</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#aaf59e45ada57c7f958a8030099cbe211">NvFlexShutdown</a>(library);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Time to integrate the solver forward in time by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">substeps</td><td>The time dt will be divided into the number of sub-steps given by this parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enableTimers</td><td>Whether to enable per-kernel timers for profiling. Note that profiling can substantially slow down overall performance so this param should only be true in non-release builds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2db6ad8006027c1acf2315a0d15fe71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_params">NvFlexParams</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update solver paramters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Parameters structure in host memory, see <a class="el" href="_nv_flex_8h.html#struct_nv_flex_params">NvFlexParams</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a581b458848039220203547af53de128f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_params">NvFlexParams</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve solver paramters, default values will be set at solver creation time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">params</td><td>Parameters structure in host memory, see <a class="el" href="_nv_flex_8h.html#struct_nv_flex_params">NvFlexParams</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc0c97635cdbb3da7b571574a3b38990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the active particles indices in the solver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Holds the indices of particles that have been made active </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bd4b70e0118abe18ca5fe85157299b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the active particle indices</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>a buffer of indices at least activeCount in length. Default values are successive numbers from 0 to maxParticles-1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a677dc591fe443ae058701966c52d1316"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetActiveCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the total number of active particles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of active particles, the first n indices in the active particles array will be used as the active count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2345372dea2ad4f043153a84e7a2c407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexGetActiveCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of active particles in the solver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of active particles in the solver </dd></dl>

</div>
</div>
<a class="anchor" id="a7ec5ebe3e98a44a2058d6be74b2cb633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the particles state of the solver, a particle consists of 4 floating point numbers, its x,y,z position followed by its inverse mass (1/m)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to a buffer of particle data, should be 4*n in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaff62cfd50431d82af5d04a6c9ac4ffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the particles state of the solver, a particle consists of 4 floating point numbers, its x,y,z position followed by its inverse mass (1/m)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Pointer to a buffer of 4*n floats that will be filled out with the particle data, can be either a host or device pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a125cfd9817437bb4f4bcb9418efa3dda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetRestParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the particle positions in their rest state, if eNvFlexPhaseSelfCollideFilter is set on the particle's phase attribute then particles that overlap in the rest state will not generate collisions with each other</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to a buffer of particle data, should be 4*n in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafc89f87307602fb9bfa8f6668122121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetRestParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the particle positions in their rest state</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to a buffer of particle data, should be 4*n in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96a771dd328d019e6164e5f23d29ffcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetSmoothParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Laplacian smoothed particle positions for rendering, see <a class="el" href="_nv_flex_8h.html#ac017e05107d0362d3d03a14eaadf0657" title="Control the strength of Laplacian smoothing in particles for rendering, if zero then smoothed positio...">NvFlexParams::smoothing</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Pointer to a buffer of 4*n floats that will be filled out with the data, can be either a host or device pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2b271f123db0054512936f2acc6467f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the particle velocities, each velocity is a 3-tuple of x,y,z floating point values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to a buffer of 3*n floats </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbcbff4e4865105514c194398ab3a7b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the particle velocities, each velocity is a 3-tuple of x,y,z floating point values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to a buffer of 3*n floats that will be filled out with the data, can be either a host or device pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1d44495e442f8cae874c635ef847478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetPhases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the particles phase id array, each particle has an associated phase id which controls how it interacts with other particles. Particles with phase 0 interact with all other phase types.</p>
<p>Particles with a non-zero phase id only interact with particles whose phase differs from theirs. This is useful, for example, to stop particles belonging to a single rigid shape from interacting with each other.</p>
<p>Phase 0 is used to indicate fluid particles when NvFlexParams::mFluid is set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phases</td><td>Pointer to a buffer of n integers containing the phases </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accc944f0e76ee2e5d67c3f977b150806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetPhases </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the particle phase ids</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">phases</td><td>Pointer to a buffer of n integers that will be filled with the phase data, can be either a host or device pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32e8fdb39029a2564c129bd493c52058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set per-particle normals to the solver, these will be overwritten after each simulation step, but can be used to initialize the normals to valid values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normals</td><td>Pointer to a buffer of normals, should be 4*n in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73d87b460a34c52ff4b616e97a53ade7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get per-particle normals from the solver, these are the world-space normals computed during surface tension, cloth, and rigid body calculations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Pointer to a buffer of normals, should be 4*n in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Describes the copy region, if NULL the solver will try to access the entire buffer (maxParticles length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae67c0cab2ecee8eb9485a26ef0fad6a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetSprings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>restLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>stiffness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSprings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set distance constraints for the solver. Each distance constraint consists of two particle indices stored consecutively, a rest-length, and a stiffness value. These are not springs in the traditional sense, but behave somewhat like a traditional spring when lowering the stiffness coefficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Pointer to the spring indices array, should be 2*numSprings length, 2 indices per-spring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restLengths</td><td>Pointer to a buffer of rest lengths, should be numSprings length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stiffness</td><td>Pointer to the spring stiffness coefficents, should be numSprings in length, a negative stiffness value represents a tether constraint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSprings</td><td>The number of springs to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab5f90f4024d71d08c3f9327c6d8c184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetSprings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>restLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>stiffness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSprings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the distance constraints from the solver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Pointer to the spring indices array, should be 2*numSprings length, 2 indices per-spring </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">restLengths</td><td>Pointer to a buffer of rest lengths, should be numSprings length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stiffness</td><td>Pointer to the spring stiffness coefficents, should be numSprings in length, a negative stiffness value represents a unilateral tether constraint (only resists stretching, not compression), valid range [-1, 1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSprings</td><td>The number of springs to get </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8b7bfeffb0fa7dc6dbd291fee87edc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetRigids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>restPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>restNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>stiffness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>thresholds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>creeps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>rotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>translations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRigids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set rigid body constraints for the solver. </p><dl class="section note"><dt>Note</dt><dd>A particle should not belong to more than one rigid body at a time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Pointer to a buffer of start offsets for a rigid in the indices array, should be numRigids+1 in length, the first entry must be 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Pointer to a buffer of indices for the rigid bodies, the indices for the jth rigid body start at indices[offsets[j]] and run to indices[offsets[j+1]] exclusive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restPositions</td><td>Pointer to a buffer of local space positions relative to the rigid's center of mass (average position), this should be at least 3*numIndices in length in the format x,y,z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restNormals</td><td>Pointer to a buffer of local space normals, this should be at least 4*numIndices in length in the format x,y,z,w where w is the (negative) signed distance of the particle inside its shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stiffness</td><td>Pointer to a buffer of rigid stiffness coefficents, should be numRigids in length, valid values in range [0, 1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresholds</td><td>Pointer to a buffer of plastic deformation threshold coefficients, should be numRigids in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">creeps</td><td>Pointer to a buffer of plastic deformation creep coefficients, should be numRigids in length, valid values in range [0, 1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotations</td><td>Pointer to a buffer of quaternions (4*numRigids in length) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">translations</td><td>Pointer to a buffer of translations of the center of mass (3*numRigids in length) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRigids</td><td>The number of rigid bodies to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numIndices</td><td>The number of indices in the indices array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5cc56e228374b1da0910356b3172b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetRigids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>restPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>restNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>stiffness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>thresholds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>creeps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>rotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>translations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrive the rigid body shape matching constraints and transforms, if any buffer pointers are NULL then they will be ignored This method supersedes the previous NvFlexGetRigidTransforms method and can be used to retrieve modified rest positions from plastic deformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Pointer to a buffer of start offsets for a rigid in the indices array, should be numRigids+1 in length, the first entry must be 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Pointer to a buffer of indices for the rigid bodies, the indices for the jth rigid body start at indices[offsets[j]] and run to indices[offsets[j+1]] exclusive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restPositions</td><td>Pointer to a buffer of local space positions relative to the rigid's center of mass (average position), this should be at least 3*numIndices in length in the format x,y,z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restNormals</td><td>Pointer to a buffer of local space normals, this should be at least 4*numIndices in length in the format x,y,z,w where w is the (negative) signed distance of the particle inside its shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stiffness</td><td>Pointer to a buffer of rigid stiffness coefficents, should be numRigids in length, valid values in range [0, 1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresholds</td><td>Pointer to a buffer of plastic deformation threshold coefficients, should be numRigids in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">creeps</td><td>Pointer to a buffer of plastic deformation creep coefficients, should be numRigids in length, valid values in range [0, 1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotations</td><td>Pointer to a buffer of quaternions (4*numRigids in length with the imaginary elements in the x,y,z components) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">translations</td><td>Pointer to a buffer of translations of the center of mass (3*numRigids in length) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdda5a5210938a1e8a7c3a8218ad468e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a> NvFlexCreateTriangleMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create triangle mesh geometry, note that meshes may be used by multiple solvers if desired</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a triangle mesh object </dd></dl>

</div>
</div>
<a class="anchor" id="a4cb4462803ebff105d151fd45b4efad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexDestroyTriangleMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a>&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a triangle mesh created with <a class="el" href="_nv_flex_8h.html#afdda5a5210938a1e8a7c3a8218ad468e">NvFlexCreateTriangleMesh()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A triangle mesh created with <a class="el" href="_nv_flex_8h.html#afdda5a5210938a1e8a7c3a8218ad468e">NvFlexCreateTriangleMesh()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1924ab797971290931b32258b847767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexGetTriangleMeshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a> *&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the list of triangle meshes in the library If the size of the array is smaller than the number of triangle meshes, only the first n entries are copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshes</td><td>Pointer to array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of triangle meshes in the library </dd></dl>

</div>
</div>
<a class="anchor" id="a4958c555f0ed65dee54c37af32529356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexUpdateTriangleMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numTriangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies the triangle mesh geometry (vertices and indices), this method will cause any internal data structures (e.g.: bounding volume hierarchies) to be rebuilt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A triangle mesh created with <a class="el" href="_nv_flex_8h.html#afdda5a5210938a1e8a7c3a8218ad468e">NvFlexCreateTriangleMesh()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>Pointer to a buffer of float4 vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Pointer to a buffer of triangle indices, should be length numTriangles*3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numVertices</td><td>The number of vertices in the vertices array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numTriangles</td><td>The number of triangles in the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>A pointer to a float3 vector holding the lower spatial bounds of the mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>A pointer to a float3 vector holding the upper spatial bounds of the mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60794d849b4184335e2a0ddec0a9e6a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetTriangleMeshBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#a2aea4c3d772b4dbccb7dd9ba37c1bdc0">NvFlexTriangleMeshId</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the local space bounds of the mesh, these are the same values specified to <a class="el" href="_nv_flex_8h.html#a4958c555f0ed65dee54c37af32529356">NvFlexUpdateTriangleMesh()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Pointer to a triangle mesh object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower</td><td>Pointer to a buffer of 3 floats that the lower mesh bounds will be written to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper</td><td>Pointer to a buffer of 3 floats that the upper mesh bounds will be written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c28caf6d5d513c5adacd4fbc782f308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a> NvFlexCreateDistanceField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a signed distance field collision shape, see NvFlexDistanceFieldId for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a signed distance field object </dd></dl>

</div>
</div>
<a class="anchor" id="ab11bdd7f778d17af16cefea33265cb65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexDestroyDistanceField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a>&#160;</td>
          <td class="paramname"><em>sdf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a signed distance field</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdf</td><td>A signed distance field created with <a class="el" href="_nv_flex_8h.html#a5c28caf6d5d513c5adacd4fbc782f308">NvFlexCreateDistanceField()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a554d54b930dad17e638ddd30c6dac46f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexGetDistanceFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a> *&#160;</td>
          <td class="paramname"><em>sdfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the list of signed distance fields in the library If the size of the array is smaller than the number of signed distance fields, only the first n entries are copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdfs</td><td>Pointer to array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of signed distance fields in the library </dd></dl>

</div>
</div>
<a class="anchor" id="a584ffb275b9986fd5444ed1a7ea247d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexUpdateDistanceField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a56e990c5bfbc89677988cbf2471c0ade">NvFlexDistanceFieldId</a>&#160;</td>
          <td class="paramname"><em>sdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the signed distance field volume data, this method will upload the field data to a 3D texture on the GPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdf</td><td>A signed distance field created with <a class="el" href="_nv_flex_8h.html#a5c28caf6d5d513c5adacd4fbc782f308">NvFlexCreateDistanceField()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimx</td><td>The x-dimension of the volume data in voxels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimy</td><td>The y-dimension of the volume data in voxels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimz</td><td>The z-dimension of the volume data in voxels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field</td><td>The volume data stored such that the voxel at the x,y,z coordinate is addressed as field[z*dimx*dimy + y*dimx + x] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbaafe2b1006352002b03aabaca531cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a> NvFlexCreateConvexMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a convex mesh collision shape, see NvFlexConvexMeshId for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a signed distance field object </dd></dl>

</div>
</div>
<a class="anchor" id="ac85b6372e5c7bfc508ecb7b8c59c72a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexDestroyConvexMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a>&#160;</td>
          <td class="paramname"><em>convex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a convex mesh</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convex</td><td>A a convex mesh created with <a class="el" href="_nv_flex_8h.html#afbaafe2b1006352002b03aabaca531cc">NvFlexCreateConvexMesh()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa392608715b2304f06606d498bd69312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexGetConvexMeshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a> *&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the list of convex meshes in the library If the size of the array is smaller than the number of convex meshes, only the first n entries are copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshes</td><td>Pointer to array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Size of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of convex meshes in the library </dd></dl>

</div>
</div>
<a class="anchor" id="ab452c355f92dda050d4b4dafb8e71b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexUpdateConvexMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a>&#160;</td>
          <td class="paramname"><em>convex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numPlanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the convex mesh geometry</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convex</td><td>A valid convex mesh shape created from <a class="el" href="_nv_flex_8h.html#afbaafe2b1006352002b03aabaca531cc">NvFlexCreateConvexMesh()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planes</td><td>An array of planes, each plane consists of 4 floats in the form a*x + b*y + c*z + d = 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPlanes</td><td>The number of planes in the convex, must be less than 64 planes per-convex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower</td><td>The local space lower bound of the convex shape </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper</td><td>The local space upper bound of the convex shape </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad56e661161763579afb375b3841eb5ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetConvexMeshBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a7ab5aa68da7ca1f69211a900f1a1c586">NvFlexConvexMeshId</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the local space bounds of the mesh, these are the same values specified to <a class="el" href="_nv_flex_8h.html#ab452c355f92dda050d4b4dafb8e71b03">NvFlexUpdateConvexMesh()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Pointer to a convex mesh object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower</td><td>Pointer to a buffer of 3 floats that the lower mesh bounds will be written to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper</td><td>Pointer to a buffer of 3 floats that the upper mesh bounds will be written to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad83b7fb561a91467a3094771bb682b96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexMakeShapeFlagsWithChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26ba">NvFlexCollisionShapeType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shapeChannels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to combine shape type, flags, and phase/shape collision channels into a 32bit value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of the shape, see NvFlexCollisionShapeType </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dynamic</td><td>See eNvFlexShapeFlagDynamic </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapeChannels</td><td>A combination of the eNvFlexPhaseShapeChannel* flags, collisions will only be processed between a particle and a shape if a channel is set on both the particle and shape, see <a class="el" href="_nv_flex_8h.html#a615e8070212c24a70e7a849120c13353">NvFlexMakePhaseWithChannels()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6ee1e23e0c49aad63df8f605182de3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexMakeShapeFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a0506ae712f846087b8647ea389ac26ba">NvFlexCollisionShapeType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deprecrated helper method that creates shape flags that by default have all collision channels enabled </p>

</div>
</div>
<a class="anchor" id="aea4e7117722df53dfe44c676496117fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetShapes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>shapePositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>shapeRotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>shapePrevPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>shapePrevRotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>shapeFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numShapes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the collision shapes for the solver</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Pointer to a buffer of <a class="el" href="_nv_flex_8h.html#union_nv_flex_collision_geometry">NvFlexCollisionGeometry</a> entries, the type of each shape determines how many entries it has in the array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapePositions</td><td>Pointer to a buffer of translations for each shape in world space, should be 4*numShapes in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapeRotations</td><td>Pointer to an a buffer of rotations for each shape stored as quaternion, should be 4*numShapes in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapePrevPositions</td><td>Pointer to a buffer of translations for each shape at the start of the time step, should be 4*numShapes in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapePrevRotations</td><td>Pointer to an a buffer of rotations for each shape stored as a quaternion at the start of the time step, should be 4*numShapees in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapeFlags</td><td>The type and behavior of the shape, NvFlexCollisionShapeFlags for more detail </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numShapes</td><td>The number of shapes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa03d94be697cdc3aaa56e469d87255a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetDynamicTriangles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numTris</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set dynamic triangles mesh indices, typically used for cloth. Flex will calculate normals and apply wind and drag effects to connected particles. See <a class="el" href="_nv_flex_8h.html#a7043181449aebf540351d1d2f785cf4a" title="Drag force applied to particles belonging to dynamic triangles, proportional to velocity^2*area in th...">NvFlexParams::drag</a>, <a class="el" href="_nv_flex_8h.html#aafb92c4fa45ce9614cdfd349b3722c8a" title="Constant acceleration applied to particles that belong to dynamic triangles, drag needs to be > 0 for...">NvFlexParams::wind</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>Pointer to a buffer of triangle indices into the particles array, should be 3*numTris in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normals</td><td>Pointer to a buffer of triangle normals, should be 3*numTris in length, can be NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numTris</td><td>The number of dynamic triangles s </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abdfd0834422dd99154a27962614525e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetDynamicTriangles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numTris</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the dynamic triangle indices and normals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Pointer to a buffer of triangle indices into the particles array, should be 3*numTris in length, if NULL indices will not be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">normals</td><td>Pointer to a buffer of triangle normals, should be 3*numTris in length, if NULL normals will be not be returned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numTris</td><td>The number of dynamic triangles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f2b59fba77c60ce116e1eac57d63e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetInflatables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>startTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>numTris</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>restVolumes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>overPressures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>constraintScales</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numInflatables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set inflatable shapes, an inflatable is a range of dynamic triangles (wound CCW) that represent a closed mesh. Each inflatable has a given rest volume, constraint scale (roughly equivalent to stiffness), and "over pressure" that controls how much the shape is inflated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startTris</td><td>Pointer to a buffer of offsets into the solver's dynamic triangles for each inflatable, should be numInflatables in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numTris</td><td>Pointer to a buffer of triangle counts for each inflatable, should be numInflatablesin length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">restVolumes</td><td>Pointer to a buffer of rest volumes for the inflatables, should be numInflatables in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">overPressures</td><td>Pointer to a buffer of floats specifying the pressures for each inflatable, a value of 1.0 means the rest volume, &gt; 1.0 means over-inflated, and &lt; 1.0 means under-inflated, should be numInflatables in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraintScales</td><td>Pointer to a buffer of scaling factors for the constraint, this is roughly equivalent to stiffness but includes a constraint scaling factor from position-based dynamics, see helper code for details, should be numInflatables in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numInflatables</td><td>Number of inflatables to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a20cc2539983a009caaf77ec9ceab82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetDensities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>densities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the density values for fluid particles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">densities</td><td>Pointer to a buffer of floats, should be maxParticles in length, density values are normalized between [0, 1] where 1 represents the rest density </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Pointer to a descriptor specifying the contents to read back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef768edc8e4df1a78a94a6c971541550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetAnisotropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>q3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_nv_flex_8h.html#struct_nv_flex_copy_desc">NvFlexCopyDesc</a> *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the anisotropy of fluid particles, the particle distribution for a particle is represented by 3 orthogonal vectors. Each 3-vector has unit length with the variance along that axis packed into the w component, i.e.: x,y,z,lambda.</p>
<p>The anisotropy defines an oriented ellipsoid in worldspace that can be used for rendering or surface extraction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q1</td><td>Pointer to a buffer of floats that receive the first basis vector and scale, should be 4*maxParticles in length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q2</td><td>Pointer to a buffer of floats that receive the second basis vector and scale, should be 4*maxParticles in length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q3</td><td>Pointer to a buffer of floats that receive the third basis vector and scale, should be 4*maxParticles in length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Pointer to a descriptor specifying the contents to read back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa458a6eec8b0d117e53c40c13788fd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetDiffuseParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the state of the diffuse particles. Diffuse particles are passively advected by the fluid velocity field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>Pointer to a buffer of floats, should be 4*maxParticles in length, the w component represents the particles lifetime with 1 representing a new particle, and 0 representing an inactive particle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to a buffer of floats, should be 4*maxParticles in length, the w component is not used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Pointer to a buffer of a single int that holds the current particle count (this may be updated by the GPU which is why it is passed back in a buffer) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a7213593dd9a23d9d67f8517d1da9de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexSetDiffuseParticles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the state of the diffuse particles. Diffuse particles are passively advected by the fluid velocity field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to a buffer of floats, should be 4*n in length, the w component represents the particles lifetime with 1 representing a new particle, and 0 representing an inactive particle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to a buffer of floats, should be 4*n in length, the w component is not used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of active diffuse particles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7edac9cf450917147b83e98f5cb09f5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetContacts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>velocities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the particle contact planes. Note this will only include contacts that were active on the last substep of an update, and will include all contact planes generated within <a class="el" href="_nv_flex_8h.html#a0e4cb2f91d3b7d122000d36a7d67ab81" title="Increases the radius used during contact finding against kinematic shapes. ">NvFlexParams::shapeCollisionMargin</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">planes</td><td>Pointer to a destination buffer containing the contact planes for the particle, each particle can have up to maxContactsPerParticle contact planes (see <a class="el" href="_nv_flex_8h.html#struct_nv_flex_solver_desc">NvFlexSolverDesc</a>) so this buffer should be 4*maxContactsPerParticle*maxParticles floats in length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">velocities</td><td>Pointer to a destination buffer containing the velocity of the contact point on the shape in world space, the index of the shape (corresponding to the shape in <a class="el" href="_nv_flex_8h.html#aea4e7117722df53dfe44c676496117fa">NvFlexSetShapes()</a> is stored in the w component), each particle can have up to maxContactsPerParticle contact planes so this buffer should be 4*maxContactsPerParticle*maxParticles floats in length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Pointer to a buffer of indices into the contacts buffer, the first contact plane for the i'th particle is given by planes[indices[i]*sizeof(float)*4*maxContactsPerParticle] and subsequent contact planes for that particle are stored sequentially, this array should be maxParticles in length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counts</td><td>Pointer to a buffer of contact counts for each particle (will be &lt;= maxContactsPerParticle), this buffer should be maxParticles in length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbee38b5413bbfd1db914c66fcdfc616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>apiToInternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>internalToApi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the particle neighbor lists, these are stored in a strided format, and can be iterated in the following manner:</p>
<div class="fragment"><div class="line"><a class="code" href="_nv_flex_8h.html#abbee38b5413bbfd1db914c66fcdfc616">NvFlexGetNeighbors</a>(solver, neighborsBuffer, countsBuffer, apiToInternalBuffer, internalToApiBuffer);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span>* neighbors = (<span class="keywordtype">int</span>*)<a class="code" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap</a>(neighborsBuffer, 0);</div>
<div class="line"><span class="keywordtype">int</span>* counts = (<span class="keywordtype">int</span>*)<a class="code" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap</a>(countsBuffer, 0);</div>
<div class="line"><span class="keywordtype">int</span>* apiToInternal = (<span class="keywordtype">int</span>*)<a class="code" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap</a>(apiToInternalBuffer, 0);</div>
<div class="line"><span class="keywordtype">int</span>* internalToApi = (<span class="keywordtype">int</span>*)<a class="code" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap</a>(internalToApiBuffer, 0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// neighbors are stored in a strided format so that the first neighbor</span></div>
<div class="line"><span class="comment">// of each particle is stored sequentially, then the second, and so on</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> stride = maxParticles;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; maxParticles; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// find offset in the neighbors buffer</span></div>
<div class="line">    <span class="keywordtype">int</span> offset = apiToInternal[i];</div>
<div class="line">    <span class="keywordtype">int</span> count = counts[offset];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c &lt; count; ++c)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> neighbor = internalToApi[neighbors[c*stride + offset]];</div>
<div class="line"></div>
<div class="line">        printf(<span class="stringliteral">&quot;Particle %d&#39;s neighbor %d is particle %d\n&quot;</span>, i, c, neighbor);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a054cb27646a389ea257d1bbde46a6e97">NvFlexUnmap</a>(neighborsBuffer);</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a054cb27646a389ea257d1bbde46a6e97">NvFlexUnmap</a>(countsBuffer);</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a054cb27646a389ea257d1bbde46a6e97">NvFlexUnmap</a>(apiToInternalBuffer);</div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a054cb27646a389ea257d1bbde46a6e97">NvFlexUnmap</a>(internalToApiBuffer);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighbors</td><td>Pointer to a destination buffer containing the the neighbors for all particles, this should be maxParticles*maxParticleNeighbors ints (passed to <a class="el" href="_nv_flex_8h.html#a687e5ec141948f779faa9183b68cb743">NvFlexInit()</a> in length) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counts</td><td>Pointer to a buffer of neighbor counts per-particle, should be maxParticles ints in length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">apiToInternal</td><td>Pointer to a buffer of indices, because Flex internally re-orders particles these are used to map from an API particle index to it internal index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">internalToApi</td><td>Pointer to a buffer of indices, because Flex internally re-orders particles these are used to map from an internal index to an API index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Neighbors are only valid after a call to <a class="el" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver()</a> has completed, the returned neighbors correspond to the last substep of the last update </dd></dl>

</div>
</div>
<a class="anchor" id="ab1eec84a21b1872fba11c9b4cc1d1629"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the world space AABB of all particles in the solver, note that the bounds are calculated during the update (see <a class="el" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver()</a>) so only become valid after an update has been performed. The returned bounds represent bounds of the particles in their predicted positions <em>before</em> the constraint solve.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower</td><td>Pointer to a buffer of 3 floats to receive the lower bounds </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper</td><td>Pointer to a buffer of 3 floats to receive the upper bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa77d2a4edd4ccd79c9389854dca80613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API float NvFlexGetDeviceLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long *&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>A valid solver </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">begin</td><td>Optional pointer to a 64 bit unsigned to receive the value of the GPU clock when Flex update began (in cycles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">end</td><td>Optional pointer to a 64 bit unsigned to receive the value of the GPU clock when Flex update ended (in cycles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frequency</td><td>Optional pointer to a 64 bit unsigned to receive the frequency of the clock used to measure begin and end </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The time in seconds between the first and last GPU operations executed by the last NvFlexUpdateSolver.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method causes the CPU to wait until the GPU has finished any outstanding work. To avoid blocking the calling thread it should be called after work has completed, e.g.: directly after a <a class="el" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab16b6d2e11e0ab417ee6c4cf16f0a27d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetTimers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_timers">NvFlexTimers</a> *&#160;</td>
          <td class="paramname"><em>timers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch high-level GPU timers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>The solver instance to use </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timers</td><td>A struct containing the GPU latency of each stage in the physics pipeline.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method causes the CPU to wait until the GPU has finished any outstanding work. To avoid blocking the calling thread it should be called after work has completed, e.g.: directly after a <a class="el" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap()</a>. To capture there timers you must pass true for enableTimers in <a class="el" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1efb6764f65900cb09f0188ad6da08a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API int NvFlexGetDetailTimers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#afaeb57f4ee7e54b1ae1b912a465ed39e">NvFlexSolver</a> *&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#struct_nv_flex_detail_timer">NvFlexDetailTimer</a> **&#160;</td>
          <td class="paramname"><em>timers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch per-shader GPU timers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>The solver instance to use </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timers</td><td>An array of <a class="el" href="_nv_flex_8h.html#struct_nv_flex_detail_timer">NvFlexDetailTimer</a> structures, each representing a unique shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of detail timers in the timers array</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method causes the CPU to wait until the GPU has finished any outstanding work. To avoid blocking the calling thread it should be called after work has completed, e.g.: directly after a <a class="el" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap()</a>. To capture there timers you must pass true for enableTimers in <a class="el" href="_nv_flex_8h.html#ac75370f005fd453fe8a324fe62be1b5c">NvFlexUpdateSolver()</a> Timers are valid until the next call to NvFlexGetDetailTimers </dd></dl>

</div>
</div>
<a class="anchor" id="ad48f83b8442323687d2268206e913496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a>* NvFlexAllocBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementByteStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a169e4c126acf46bdebf76c36a44deca3">NvFlexBufferType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a Flex buffer. Buffers are used to pass data to the API in an efficient manner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementCount</td><td>The number of elements in the buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementByteStride</td><td>The size of each element in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of buffer to allocate, can be either host memory or device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a NvFlexBuffer </dd></dl>

</div>
</div>
<a class="anchor" id="ab559759820a4322aff061745ef26c867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexFreeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a Flex buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A buffer to free, must be allocated with <a class="el" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0898bb9210440b159688d4647f6eb083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void* NvFlexMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps a buffer for reading and writing. When the buffer is created with NvFlexBufferType::eHost, then the returned pointer will be a host memory address that can be read/written. Mapping a buffer implicitly synchronizes with the GPU to ensure that any reads or writes from the buffer (e.g.: from the NvFlexGet*() or NvFlexSet*() methods) have completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A buffer allocated with <a class="el" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Hints to Flex how the buffer is to be accessed, typically this should be eNvFlexMapWait (0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the mapped memory </dd></dl>

</div>
</div>
<a class="anchor" id="a054cb27646a389ea257d1bbde46a6e97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexUnmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmaps a buffer that was mapped through <a class="el" href="_nv_flex_8h.html#a0898bb9210440b159688d4647f6eb083">NvFlexMap()</a>, note that buffers must be unmapped before they can be passed to a NvFlexGet*() or NvFlexSet*() method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A valid buffer allocated through <a class="el" href="_nv_flex_8h.html#ad48f83b8442323687d2268206e913496">NvFlexAllocBuffer()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab83daf46e5a9428a0ad76fb75e8ec7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a>* NvFlexRegisterOGLBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementByteStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an OpenGL buffer to Flex which can be used to copy directly into a graphics resource. Example usage is below</p>
<div class="fragment"><div class="line">GLuint vbo;</div>
<div class="line">glGenBuffers(1, &amp;vbo);</div>
<div class="line">glBindBuffer(GL_ARRAY_BUFFER, vbo);</div>
<div class="line">glBufferData(GL_ARRAY_BUFFER, size, NULL, GL_DYNAMIC_DRAW)</div>
<div class="line"></div>
<div class="line"><a class="code" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a>* vboBuffer = <a class="code" href="_nv_flex_8h.html#aab83daf46e5a9428a0ad76fb75e8ec7e">NvFlexRegisterOGLBuffer</a>(lib, vbo, n, sizeof(<span class="keywordtype">float</span>)*4);</div>
<div class="line"></div>
<div class="line"><span class="comment">// simulate </span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// copy directly from Flex into render buffer</span></div>
<div class="line"><a class="code" href="_nv_flex_8h.html#aaff62cfd50431d82af5d04a6c9ac4ffd">NvFlexGetParticles</a>(vboBuffer, n);</div>
<div class="line"></div>
<div class="line"><span class="comment">// render</span></div>
<div class="line">...</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>An OpenGL buffer identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementCount</td><td>The number of elements in the buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementByteStride</td><td>the size of each element in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid NvFlexBuffer pointer that may be used with NvFlexGet*() methods to populate the render buffer using direct GPU-GPU copies </dd></dl>

</div>
</div>
<a class="anchor" id="a78045a8d4e856372df108dc616a94cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexUnregisterOGLBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a NvFlexBuffer allocated through <a class="el" href="_nv_flex_8h.html#aab83daf46e5a9428a0ad76fb75e8ec7e">NvFlexRegisterOGLBuffer()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A valid buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab487e68ce1c84ce1eec0c85b7daf5aa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API <a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a>* NvFlexRegisterD3DBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementByteStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a Direct3D buffer to Flex which can be used to copy directly into a graphics resource</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>A pointer to either an ID3D11Buffer or ID3D12Resource object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementCount</td><td>The number of elements in the buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementByteStride</td><td>the size of each element in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid NvFlexBuffer pointer that may be used with NvFlexGet*() methods to populate the render buffer using direct GPU-GPU copies </dd></dl>

</div>
</div>
<a class="anchor" id="ad607e7916e5d76b384a61f1c1f94ab32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexUnregisterD3DBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a50a3933d3f7b77d0500c702b1fa9ba9a">NvFlexBuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a NvFlexBuffer allocated through NvFlexRegistereD3DBuffer()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A valid buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42ec7b30c79d4733e6a756b5d9b15ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexAcquireContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensures that the CUDA context the library was initialized with is present on the current thread</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6671f352bd77e296609d0bc2a57fd11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexRestoreContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores the CUDA context (if any) that was present on the last call to <a class="el" href="_nv_flex_8h.html#a42ec7b30c79d4733e6a756b5d9b15ee6">NvFlexAcquireContext()</a> Note: the acquire/restore pair of calls must come from the same thread </p>

</div>
</div>
<a class="anchor" id="a4c451971259524c6878b6b1ed4023ada"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API const char* NvFlexGetDeviceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a null-terminated string with the compute device name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ac0a898a565a2cdf13b80acd4a3555c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexGetDeviceAndContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the device and context for the the library. On CUDA the context pointer will be filled with a pointer to a CUcontext structure On D3D the device and context pointers will be filled with pointers to a NvFlex::Device, and NvFlex::Context wrapper</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>Pointer to a valid library returned from <a class="el" href="_nv_flex_8h.html#a687e5ec141948f779faa9183b68cb743">NvFlexInit()</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">device</td><td>Pointer to a device pointer, see description </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>Pointer to a context pointer, see description </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a898eb8e66a456dd2266c694f29cab600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force a pipeline flush to ensure any queued work is submitted to the GPU</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lib</td><td>The library instance to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a615d2e6eec2486a5db815d929f9c642c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FLEX_API void NvFlexWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_flex_8h.html#a3078976e98f370a9fbdb11db80f1f318">NvFlexLibrary</a> *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 19 2018 14:53:17 for FLEX by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
